// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pvisit.proto

#ifndef PROTOBUF_pvisit_2eproto__INCLUDED
#define PROTOBUF_pvisit_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "penums.pb.h"
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pvisit_2eproto();
void protobuf_AssignDesc_pvisit_2eproto();
void protobuf_ShutdownFile_pvisit_2eproto();

class KVI;
class KVS;
class KVF;
class PR;
class VisitEdge;
class Visit;
class Patient;
class PatientList;
class VisitList;

// ===================================================================

class KVI : public ::google::protobuf::Message {
 public:
  KVI();
  virtual ~KVI();

  KVI(const KVI& from);

  inline KVI& operator=(const KVI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVI& default_instance();

  void Swap(KVI* other);

  // implements Message ----------------------------------------------

  KVI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVI& from);
  void MergeFrom(const KVI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // optional float f = 4;
  inline bool has_f() const;
  inline void clear_f();
  static const int kFFieldNumber = 4;
  inline float f() const;
  inline void set_f(float value);

  // @@protoc_insertion_point(class_scope:comphealth.KVI)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_f();
  inline void clear_has_f();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::std::string* s_;
  ::google::protobuf::int32 v_;
  float f_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static KVI* default_instance_;
};
// -------------------------------------------------------------------

class KVS : public ::google::protobuf::Message {
 public:
  KVS();
  virtual ~KVS();

  KVS(const KVS& from);

  inline KVS& operator=(const KVS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVS& default_instance();

  void Swap(KVS* other);

  // implements Message ----------------------------------------------

  KVS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVS& from);
  void MergeFrom(const KVS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // required string v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline const ::std::string& v() const;
  inline void set_v(const ::std::string& value);
  inline void set_v(const char* value);
  inline void set_v(const char* value, size_t size);
  inline ::std::string* mutable_v();
  inline ::std::string* release_v();
  inline void set_allocated_v(::std::string* v);

  // @@protoc_insertion_point(class_scope:comphealth.KVS)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::std::string* v_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static KVS* default_instance_;
};
// -------------------------------------------------------------------

class KVF : public ::google::protobuf::Message {
 public:
  KVF();
  virtual ~KVF();

  KVF(const KVF& from);

  inline KVF& operator=(const KVF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVF& default_instance();

  void Swap(KVF* other);

  // implements Message ----------------------------------------------

  KVF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVF& from);
  void MergeFrom(const KVF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // required float v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline float v() const;
  inline void set_v(float value);

  // @@protoc_insertion_point(class_scope:comphealth.KVF)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  float v_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static KVF* default_instance_;
};
// -------------------------------------------------------------------

class PR : public ::google::protobuf::Message {
 public:
  PR();
  virtual ~PR();

  PR(const PR& from);

  inline PR& operator=(const PR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PR& default_instance();

  void Swap(PR* other);

  // implements Message ----------------------------------------------

  PR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PR& from);
  void MergeFrom(const PR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pcode = 1;
  inline bool has_pcode() const;
  inline void clear_pcode();
  static const int kPcodeFieldNumber = 1;
  inline const ::std::string& pcode() const;
  inline void set_pcode(const ::std::string& value);
  inline void set_pcode(const char* value);
  inline void set_pcode(const char* value, size_t size);
  inline ::std::string* mutable_pcode();
  inline ::std::string* release_pcode();
  inline void set_allocated_pcode(::std::string* pcode);

  // optional int32 pday = 2;
  inline bool has_pday() const;
  inline void clear_pday();
  static const int kPdayFieldNumber = 2;
  inline ::google::protobuf::int32 pday() const;
  inline void set_pday(::google::protobuf::int32 value);

  // required .comphealth.CTYPE ctype = 3;
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kCtypeFieldNumber = 3;
  inline ::comphealth::CTYPE ctype() const;
  inline void set_ctype(::comphealth::CTYPE value);

  // optional int32 occur = 4 [default = 1];
  inline bool has_occur() const;
  inline void clear_occur();
  static const int kOccurFieldNumber = 4;
  inline ::google::protobuf::int32 occur() const;
  inline void set_occur(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.PR)
 private:
  inline void set_has_pcode();
  inline void clear_has_pcode();
  inline void set_has_pday();
  inline void clear_has_pday();
  inline void set_has_ctype();
  inline void clear_has_ctype();
  inline void set_has_occur();
  inline void clear_has_occur();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pcode_;
  ::google::protobuf::int32 pday_;
  int ctype_;
  ::google::protobuf::int32 occur_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static PR* default_instance_;
};
// -------------------------------------------------------------------

class VisitEdge : public ::google::protobuf::Message {
 public:
  VisitEdge();
  virtual ~VisitEdge();

  VisitEdge(const VisitEdge& from);

  inline VisitEdge& operator=(const VisitEdge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisitEdge& default_instance();

  void Swap(VisitEdge* other);

  // implements Message ----------------------------------------------

  VisitEdge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisitEdge& from);
  void MergeFrom(const VisitEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.Visit initial = 1;
  inline bool has_initial() const;
  inline void clear_initial();
  static const int kInitialFieldNumber = 1;
  inline const ::comphealth::Visit& initial() const;
  inline ::comphealth::Visit* mutable_initial();
  inline ::comphealth::Visit* release_initial();
  inline void set_allocated_initial(::comphealth::Visit* initial);

  // required .comphealth.Visit sub = 2;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 2;
  inline const ::comphealth::Visit& sub() const;
  inline ::comphealth::Visit* mutable_sub();
  inline ::comphealth::Visit* release_sub();
  inline void set_allocated_sub(::comphealth::Visit* sub);

  // @@protoc_insertion_point(class_scope:comphealth.VisitEdge)
 private:
  inline void set_has_initial();
  inline void clear_has_initial();
  inline void set_has_sub();
  inline void clear_has_sub();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::comphealth::Visit* initial_;
  ::comphealth::Visit* sub_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static VisitEdge* default_instance_;
};
// -------------------------------------------------------------------

class Visit : public ::google::protobuf::Message {
 public:
  Visit();
  virtual ~Visit();

  Visit(const Visit& from);

  inline Visit& operator=(const Visit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Visit& default_instance();

  void Swap(Visit* other);

  // implements Message ----------------------------------------------

  Visit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Visit& from);
  void MergeFrom(const Visit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string patient_key = 2;
  inline bool has_patient_key() const;
  inline void clear_patient_key();
  static const int kPatientKeyFieldNumber = 2;
  inline const ::std::string& patient_key() const;
  inline void set_patient_key(const ::std::string& value);
  inline void set_patient_key(const char* value);
  inline void set_patient_key(const char* value, size_t size);
  inline ::std::string* mutable_patient_key();
  inline ::std::string* release_patient_key();
  inline void set_allocated_patient_key(::std::string* patient_key);

  // required string dataset = 3;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 3;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // required string state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // required string facility = 5;
  inline bool has_facility() const;
  inline void clear_facility();
  static const int kFacilityFieldNumber = 5;
  inline const ::std::string& facility() const;
  inline void set_facility(const ::std::string& value);
  inline void set_facility(const char* value);
  inline void set_facility(const char* value, size_t size);
  inline ::std::string* mutable_facility();
  inline ::std::string* release_facility();
  inline void set_allocated_facility(::std::string* facility);

  // required .comphealth.ETYPE vtype = 6;
  inline bool has_vtype() const;
  inline void clear_vtype();
  static const int kVtypeFieldNumber = 6;
  inline ::comphealth::ETYPE vtype() const;
  inline void set_vtype(::comphealth::ETYPE value);

  // required int32 age = 7 [default = -1];
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 7;
  inline ::google::protobuf::int32 age() const;
  inline void set_age(::google::protobuf::int32 value);

  // required .comphealth.SEX sex = 8;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 8;
  inline ::comphealth::SEX sex() const;
  inline void set_sex(::comphealth::SEX value);

  // required .comphealth.RACE race = 9;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 9;
  inline ::comphealth::RACE race() const;
  inline void set_race(::comphealth::RACE value);

  // required .comphealth.SOURCE source = 10;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 10;
  inline ::comphealth::SOURCE source() const;
  inline void set_source(::comphealth::SOURCE value);

  // required .comphealth.DISPOSITION disposition = 11;
  inline bool has_disposition() const;
  inline void clear_disposition();
  static const int kDispositionFieldNumber = 11;
  inline ::comphealth::DISPOSITION disposition() const;
  inline void set_disposition(::comphealth::DISPOSITION value);

  // required int32 los = 12;
  inline bool has_los() const;
  inline void clear_los();
  static const int kLosFieldNumber = 12;
  inline ::google::protobuf::int32 los() const;
  inline void set_los(::google::protobuf::int32 value);

  // required .comphealth.DEATH death = 13;
  inline bool has_death() const;
  inline void clear_death();
  static const int kDeathFieldNumber = 13;
  inline ::comphealth::DEATH death() const;
  inline void set_death(::comphealth::DEATH value);

  // required .comphealth.PAYER payer = 14;
  inline bool has_payer() const;
  inline void clear_payer();
  static const int kPayerFieldNumber = 14;
  inline ::comphealth::PAYER payer() const;
  inline void set_payer(::comphealth::PAYER value);

  // required string primary_diagnosis = 15;
  inline bool has_primary_diagnosis() const;
  inline void clear_primary_diagnosis();
  static const int kPrimaryDiagnosisFieldNumber = 15;
  inline const ::std::string& primary_diagnosis() const;
  inline void set_primary_diagnosis(const ::std::string& value);
  inline void set_primary_diagnosis(const char* value);
  inline void set_primary_diagnosis(const char* value, size_t size);
  inline ::std::string* mutable_primary_diagnosis();
  inline ::std::string* release_primary_diagnosis();
  inline void set_allocated_primary_diagnosis(::std::string* primary_diagnosis);

  // optional .comphealth.PR primary_procedure = 16;
  inline bool has_primary_procedure() const;
  inline void clear_primary_procedure();
  static const int kPrimaryProcedureFieldNumber = 16;
  inline const ::comphealth::PR& primary_procedure() const;
  inline ::comphealth::PR* mutable_primary_procedure();
  inline ::comphealth::PR* release_primary_procedure();
  inline void set_allocated_primary_procedure(::comphealth::PR* primary_procedure);

  // required string drg = 18;
  inline bool has_drg() const;
  inline void clear_drg();
  static const int kDrgFieldNumber = 18;
  inline const ::std::string& drg() const;
  inline void set_drg(const ::std::string& value);
  inline void set_drg(const char* value);
  inline void set_drg(const char* value, size_t size);
  inline ::std::string* mutable_drg();
  inline ::std::string* release_drg();
  inline void set_allocated_drg(::std::string* drg);

  // repeated string dxs = 19;
  inline int dxs_size() const;
  inline void clear_dxs();
  static const int kDxsFieldNumber = 19;
  inline const ::std::string& dxs(int index) const;
  inline ::std::string* mutable_dxs(int index);
  inline void set_dxs(int index, const ::std::string& value);
  inline void set_dxs(int index, const char* value);
  inline void set_dxs(int index, const char* value, size_t size);
  inline ::std::string* add_dxs();
  inline void add_dxs(const ::std::string& value);
  inline void add_dxs(const char* value);
  inline void add_dxs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dxs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dxs();

  // repeated string exs = 20;
  inline int exs_size() const;
  inline void clear_exs();
  static const int kExsFieldNumber = 20;
  inline const ::std::string& exs(int index) const;
  inline ::std::string* mutable_exs(int index);
  inline void set_exs(int index, const ::std::string& value);
  inline void set_exs(int index, const char* value);
  inline void set_exs(int index, const char* value, size_t size);
  inline ::std::string* add_exs();
  inline void add_exs(const ::std::string& value);
  inline void add_exs(const char* value);
  inline void add_exs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exs();

  // repeated string poas = 37;
  inline int poas_size() const;
  inline void clear_poas();
  static const int kPoasFieldNumber = 37;
  inline const ::std::string& poas(int index) const;
  inline ::std::string* mutable_poas(int index);
  inline void set_poas(int index, const ::std::string& value);
  inline void set_poas(int index, const char* value);
  inline void set_poas(int index, const char* value, size_t size);
  inline ::std::string* add_poas();
  inline void add_poas(const ::std::string& value);
  inline void add_poas(const char* value);
  inline void add_poas(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& poas() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_poas();

  // repeated .comphealth.PR prs = 21;
  inline int prs_size() const;
  inline void clear_prs();
  static const int kPrsFieldNumber = 21;
  inline const ::comphealth::PR& prs(int index) const;
  inline ::comphealth::PR* mutable_prs(int index);
  inline ::comphealth::PR* add_prs();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PR >&
      prs() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::PR >*
      mutable_prs();

  // required int32 year = 22;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 22;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);

  // required int32 day = 23;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 23;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // required int32 month = 24 [default = -1];
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 24;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);

  // required int32 quarter = 26 [default = -1];
  inline bool has_quarter() const;
  inline void clear_quarter();
  static const int kQuarterFieldNumber = 26;
  inline ::google::protobuf::int32 quarter() const;
  inline void set_quarter(::google::protobuf::int32 value);

  // required .comphealth.PZIP zip = 27;
  inline bool has_zip() const;
  inline void clear_zip();
  static const int kZipFieldNumber = 27;
  inline ::comphealth::PZIP zip() const;
  inline void set_zip(::comphealth::PZIP value);

  // required .comphealth.DNR dnr = 28;
  inline bool has_dnr() const;
  inline void clear_dnr();
  static const int kDnrFieldNumber = 28;
  inline ::comphealth::DNR dnr() const;
  inline void set_dnr(::comphealth::DNR value);

  // required float charge = 30;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 30;
  inline float charge() const;
  inline void set_charge(float value);

  // repeated .comphealth.KVS dstring = 34;
  inline int dstring_size() const;
  inline void clear_dstring();
  static const int kDstringFieldNumber = 34;
  inline const ::comphealth::KVS& dstring(int index) const;
  inline ::comphealth::KVS* mutable_dstring(int index);
  inline ::comphealth::KVS* add_dstring();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVS >&
      dstring() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVS >*
      mutable_dstring();

  // repeated .comphealth.KVI dint = 35;
  inline int dint_size() const;
  inline void clear_dint();
  static const int kDintFieldNumber = 35;
  inline const ::comphealth::KVI& dint(int index) const;
  inline ::comphealth::KVI* mutable_dint(int index);
  inline ::comphealth::KVI* add_dint();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
      dint() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
      mutable_dint();

  // repeated .comphealth.KVF dfloat = 36;
  inline int dfloat_size() const;
  inline void clear_dfloat();
  static const int kDfloatFieldNumber = 36;
  inline const ::comphealth::KVF& dfloat(int index) const;
  inline ::comphealth::KVF* mutable_dfloat(int index);
  inline ::comphealth::KVF* add_dfloat();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVF >&
      dfloat() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVF >*
      mutable_dfloat();

  // @@protoc_insertion_point(class_scope:comphealth.Visit)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_patient_key();
  inline void clear_has_patient_key();
  inline void set_has_dataset();
  inline void clear_has_dataset();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_facility();
  inline void clear_has_facility();
  inline void set_has_vtype();
  inline void clear_has_vtype();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_disposition();
  inline void clear_has_disposition();
  inline void set_has_los();
  inline void clear_has_los();
  inline void set_has_death();
  inline void clear_has_death();
  inline void set_has_payer();
  inline void clear_has_payer();
  inline void set_has_primary_diagnosis();
  inline void clear_has_primary_diagnosis();
  inline void set_has_primary_procedure();
  inline void clear_has_primary_procedure();
  inline void set_has_drg();
  inline void clear_has_drg();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_quarter();
  inline void clear_has_quarter();
  inline void set_has_zip();
  inline void clear_has_zip();
  inline void set_has_dnr();
  inline void clear_has_dnr();
  inline void set_has_charge();
  inline void clear_has_charge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* patient_key_;
  ::std::string* dataset_;
  ::std::string* state_;
  ::std::string* facility_;
  int vtype_;
  ::google::protobuf::int32 age_;
  int sex_;
  int race_;
  int source_;
  int disposition_;
  ::google::protobuf::int32 los_;
  int death_;
  ::std::string* primary_diagnosis_;
  ::comphealth::PR* primary_procedure_;
  ::std::string* drg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dxs_;
  int payer_;
  ::google::protobuf::int32 year_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> poas_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::PR > prs_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 quarter_;
  int zip_;
  int dnr_;
  float charge_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVS > dstring_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVI > dint_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVF > dfloat_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static Visit* default_instance_;
};
// -------------------------------------------------------------------

class Patient : public ::google::protobuf::Message {
 public:
  Patient();
  virtual ~Patient();

  Patient(const Patient& from);

  inline Patient& operator=(const Patient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patient& default_instance();

  void Swap(Patient* other);

  // implements Message ----------------------------------------------

  Patient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patient& from);
  void MergeFrom(const Patient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string patient_key = 1;
  inline bool has_patient_key() const;
  inline void clear_patient_key();
  static const int kPatientKeyFieldNumber = 1;
  inline const ::std::string& patient_key() const;
  inline void set_patient_key(const ::std::string& value);
  inline void set_patient_key(const char* value);
  inline void set_patient_key(const char* value, size_t size);
  inline ::std::string* mutable_patient_key();
  inline ::std::string* release_patient_key();
  inline void set_allocated_patient_key(::std::string* patient_key);

  // repeated .comphealth.Visit visits = 2;
  inline int visits_size() const;
  inline void clear_visits();
  static const int kVisitsFieldNumber = 2;
  inline const ::comphealth::Visit& visits(int index) const;
  inline ::comphealth::Visit* mutable_visits(int index);
  inline ::comphealth::Visit* add_visits();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >&
      visits() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >*
      mutable_visits();

  // optional string raw = 3;
  inline bool has_raw() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 3;
  inline const ::std::string& raw() const;
  inline void set_raw(const ::std::string& value);
  inline void set_raw(const char* value);
  inline void set_raw(const char* value, size_t size);
  inline ::std::string* mutable_raw();
  inline ::std::string* release_raw();
  inline void set_allocated_raw(::std::string* raw);

  // optional bool linked = 4 [default = false];
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 4;
  inline bool linked() const;
  inline void set_linked(bool value);

  // @@protoc_insertion_point(class_scope:comphealth.Patient)
 private:
  inline void set_has_patient_key();
  inline void clear_has_patient_key();
  inline void set_has_raw();
  inline void clear_has_raw();
  inline void set_has_linked();
  inline void clear_has_linked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* patient_key_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Visit > visits_;
  ::std::string* raw_;
  bool linked_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static Patient* default_instance_;
};
// -------------------------------------------------------------------

class PatientList : public ::google::protobuf::Message {
 public:
  PatientList();
  virtual ~PatientList();

  PatientList(const PatientList& from);

  inline PatientList& operator=(const PatientList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatientList& default_instance();

  void Swap(PatientList* other);

  // implements Message ----------------------------------------------

  PatientList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatientList& from);
  void MergeFrom(const PatientList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .comphealth.Patient patients = 1;
  inline int patients_size() const;
  inline void clear_patients();
  static const int kPatientsFieldNumber = 1;
  inline const ::comphealth::Patient& patients(int index) const;
  inline ::comphealth::Patient* mutable_patients(int index);
  inline ::comphealth::Patient* add_patients();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Patient >&
      patients() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Patient >*
      mutable_patients();

  // @@protoc_insertion_point(class_scope:comphealth.PatientList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Patient > patients_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static PatientList* default_instance_;
};
// -------------------------------------------------------------------

class VisitList : public ::google::protobuf::Message {
 public:
  VisitList();
  virtual ~VisitList();

  VisitList(const VisitList& from);

  inline VisitList& operator=(const VisitList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisitList& default_instance();

  void Swap(VisitList* other);

  // implements Message ----------------------------------------------

  VisitList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisitList& from);
  void MergeFrom(const VisitList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .comphealth.Visit visits = 1;
  inline int visits_size() const;
  inline void clear_visits();
  static const int kVisitsFieldNumber = 1;
  inline const ::comphealth::Visit& visits(int index) const;
  inline ::comphealth::Visit* mutable_visits(int index);
  inline ::comphealth::Visit* add_visits();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >&
      visits() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >*
      mutable_visits();

  // @@protoc_insertion_point(class_scope:comphealth.VisitList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Visit > visits_;
  friend void  protobuf_AddDesc_pvisit_2eproto();
  friend void protobuf_AssignDesc_pvisit_2eproto();
  friend void protobuf_ShutdownFile_pvisit_2eproto();

  void InitAsDefaultInstance();
  static VisitList* default_instance_;
};
// ===================================================================


// ===================================================================

// KVI

// required string k = 1;
inline bool KVI::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVI::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVI::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVI::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& KVI::k() const {
  // @@protoc_insertion_point(field_get:comphealth.KVI.k)
  return *k_;
}
inline void KVI::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVI.k)
}
inline void KVI::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVI.k)
}
inline void KVI::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVI.k)
}
inline ::std::string* KVI::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVI.k)
  return k_;
}
inline ::std::string* KVI::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVI::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVI.k)
}

// required int32 v = 2;
inline bool KVI::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVI::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVI::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVI::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 KVI::v() const {
  // @@protoc_insertion_point(field_get:comphealth.KVI.v)
  return v_;
}
inline void KVI::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.KVI.v)
}

// optional string s = 3;
inline bool KVI::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KVI::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KVI::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KVI::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& KVI::s() const {
  // @@protoc_insertion_point(field_get:comphealth.KVI.s)
  return *s_;
}
inline void KVI::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVI.s)
}
inline void KVI::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVI.s)
}
inline void KVI::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVI.s)
}
inline ::std::string* KVI::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVI.s)
  return s_;
}
inline ::std::string* KVI::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVI::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVI.s)
}

// optional float f = 4;
inline bool KVI::has_f() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KVI::set_has_f() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KVI::clear_has_f() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KVI::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float KVI::f() const {
  // @@protoc_insertion_point(field_get:comphealth.KVI.f)
  return f_;
}
inline void KVI::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:comphealth.KVI.f)
}

// -------------------------------------------------------------------

// KVS

// required string k = 1;
inline bool KVS::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVS::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVS::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVS::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& KVS::k() const {
  // @@protoc_insertion_point(field_get:comphealth.KVS.k)
  return *k_;
}
inline void KVS::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVS.k)
}
inline void KVS::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVS.k)
}
inline void KVS::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVS.k)
}
inline ::std::string* KVS::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVS.k)
  return k_;
}
inline ::std::string* KVS::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVS::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVS.k)
}

// required string v = 2;
inline bool KVS::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVS::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVS::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVS::clear_v() {
  if (v_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    v_->clear();
  }
  clear_has_v();
}
inline const ::std::string& KVS::v() const {
  // @@protoc_insertion_point(field_get:comphealth.KVS.v)
  return *v_;
}
inline void KVS::set_v(const ::std::string& value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    v_ = new ::std::string;
  }
  v_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVS.v)
}
inline void KVS::set_v(const char* value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    v_ = new ::std::string;
  }
  v_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVS.v)
}
inline void KVS::set_v(const char* value, size_t size) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    v_ = new ::std::string;
  }
  v_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVS.v)
}
inline ::std::string* KVS::mutable_v() {
  set_has_v();
  if (v_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    v_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVS.v)
  return v_;
}
inline ::std::string* KVS::release_v() {
  clear_has_v();
  if (v_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = v_;
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVS::set_allocated_v(::std::string* v) {
  if (v_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete v_;
  }
  if (v) {
    set_has_v();
    v_ = v;
  } else {
    clear_has_v();
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVS.v)
}

// -------------------------------------------------------------------

// KVF

// required string k = 1;
inline bool KVF::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVF::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVF::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVF::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& KVF::k() const {
  // @@protoc_insertion_point(field_get:comphealth.KVF.k)
  return *k_;
}
inline void KVF::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVF.k)
}
inline void KVF::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVF.k)
}
inline void KVF::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVF.k)
}
inline ::std::string* KVF::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVF.k)
  return k_;
}
inline ::std::string* KVF::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVF::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVF.k)
}

// required float v = 2;
inline bool KVF::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVF::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVF::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVF::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline float KVF::v() const {
  // @@protoc_insertion_point(field_get:comphealth.KVF.v)
  return v_;
}
inline void KVF::set_v(float value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.KVF.v)
}

// -------------------------------------------------------------------

// PR

// required string pcode = 1;
inline bool PR::has_pcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PR::set_has_pcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PR::clear_has_pcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PR::clear_pcode() {
  if (pcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pcode_->clear();
  }
  clear_has_pcode();
}
inline const ::std::string& PR::pcode() const {
  // @@protoc_insertion_point(field_get:comphealth.PR.pcode)
  return *pcode_;
}
inline void PR::set_pcode(const ::std::string& value) {
  set_has_pcode();
  if (pcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pcode_ = new ::std::string;
  }
  pcode_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PR.pcode)
}
inline void PR::set_pcode(const char* value) {
  set_has_pcode();
  if (pcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pcode_ = new ::std::string;
  }
  pcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PR.pcode)
}
inline void PR::set_pcode(const char* value, size_t size) {
  set_has_pcode();
  if (pcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pcode_ = new ::std::string;
  }
  pcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PR.pcode)
}
inline ::std::string* PR::mutable_pcode() {
  set_has_pcode();
  if (pcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PR.pcode)
  return pcode_;
}
inline ::std::string* PR::release_pcode() {
  clear_has_pcode();
  if (pcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pcode_;
    pcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PR::set_allocated_pcode(::std::string* pcode) {
  if (pcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pcode_;
  }
  if (pcode) {
    set_has_pcode();
    pcode_ = pcode;
  } else {
    clear_has_pcode();
    pcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PR.pcode)
}

// optional int32 pday = 2;
inline bool PR::has_pday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PR::set_has_pday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PR::clear_has_pday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PR::clear_pday() {
  pday_ = 0;
  clear_has_pday();
}
inline ::google::protobuf::int32 PR::pday() const {
  // @@protoc_insertion_point(field_get:comphealth.PR.pday)
  return pday_;
}
inline void PR::set_pday(::google::protobuf::int32 value) {
  set_has_pday();
  pday_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PR.pday)
}

// required .comphealth.CTYPE ctype = 3;
inline bool PR::has_ctype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PR::set_has_ctype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PR::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PR::clear_ctype() {
  ctype_ = 90;
  clear_has_ctype();
}
inline ::comphealth::CTYPE PR::ctype() const {
  // @@protoc_insertion_point(field_get:comphealth.PR.ctype)
  return static_cast< ::comphealth::CTYPE >(ctype_);
}
inline void PR::set_ctype(::comphealth::CTYPE value) {
  assert(::comphealth::CTYPE_IsValid(value));
  set_has_ctype();
  ctype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PR.ctype)
}

// optional int32 occur = 4 [default = 1];
inline bool PR::has_occur() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PR::set_has_occur() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PR::clear_has_occur() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PR::clear_occur() {
  occur_ = 1;
  clear_has_occur();
}
inline ::google::protobuf::int32 PR::occur() const {
  // @@protoc_insertion_point(field_get:comphealth.PR.occur)
  return occur_;
}
inline void PR::set_occur(::google::protobuf::int32 value) {
  set_has_occur();
  occur_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PR.occur)
}

// -------------------------------------------------------------------

// VisitEdge

// required .comphealth.Visit initial = 1;
inline bool VisitEdge::has_initial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisitEdge::set_has_initial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisitEdge::clear_has_initial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisitEdge::clear_initial() {
  if (initial_ != NULL) initial_->::comphealth::Visit::Clear();
  clear_has_initial();
}
inline const ::comphealth::Visit& VisitEdge::initial() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitEdge.initial)
  return initial_ != NULL ? *initial_ : *default_instance_->initial_;
}
inline ::comphealth::Visit* VisitEdge::mutable_initial() {
  set_has_initial();
  if (initial_ == NULL) initial_ = new ::comphealth::Visit;
  // @@protoc_insertion_point(field_mutable:comphealth.VisitEdge.initial)
  return initial_;
}
inline ::comphealth::Visit* VisitEdge::release_initial() {
  clear_has_initial();
  ::comphealth::Visit* temp = initial_;
  initial_ = NULL;
  return temp;
}
inline void VisitEdge::set_allocated_initial(::comphealth::Visit* initial) {
  delete initial_;
  initial_ = initial;
  if (initial) {
    set_has_initial();
  } else {
    clear_has_initial();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VisitEdge.initial)
}

// required .comphealth.Visit sub = 2;
inline bool VisitEdge::has_sub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisitEdge::set_has_sub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisitEdge::clear_has_sub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisitEdge::clear_sub() {
  if (sub_ != NULL) sub_->::comphealth::Visit::Clear();
  clear_has_sub();
}
inline const ::comphealth::Visit& VisitEdge::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitEdge.sub)
  return sub_ != NULL ? *sub_ : *default_instance_->sub_;
}
inline ::comphealth::Visit* VisitEdge::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) sub_ = new ::comphealth::Visit;
  // @@protoc_insertion_point(field_mutable:comphealth.VisitEdge.sub)
  return sub_;
}
inline ::comphealth::Visit* VisitEdge::release_sub() {
  clear_has_sub();
  ::comphealth::Visit* temp = sub_;
  sub_ = NULL;
  return temp;
}
inline void VisitEdge::set_allocated_sub(::comphealth::Visit* sub) {
  delete sub_;
  sub_ = sub;
  if (sub) {
    set_has_sub();
  } else {
    clear_has_sub();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VisitEdge.sub)
}

// -------------------------------------------------------------------

// Visit

// required string key = 1;
inline bool Visit::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Visit::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Visit::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Visit::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Visit::key() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.key)
  return *key_;
}
inline void Visit::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.key)
}
inline void Visit::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.key)
}
inline void Visit::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.key)
}
inline ::std::string* Visit::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.key)
  return key_;
}
inline ::std::string* Visit::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.key)
}

// required string patient_key = 2;
inline bool Visit::has_patient_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Visit::set_has_patient_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Visit::clear_has_patient_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Visit::clear_patient_key() {
  if (patient_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_->clear();
  }
  clear_has_patient_key();
}
inline const ::std::string& Visit::patient_key() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.patient_key)
  return *patient_key_;
}
inline void Visit::set_patient_key(const ::std::string& value) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.patient_key)
}
inline void Visit::set_patient_key(const char* value) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.patient_key)
}
inline void Visit::set_patient_key(const char* value, size_t size) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.patient_key)
}
inline ::std::string* Visit::mutable_patient_key() {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.patient_key)
  return patient_key_;
}
inline ::std::string* Visit::release_patient_key() {
  clear_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patient_key_;
    patient_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_patient_key(::std::string* patient_key) {
  if (patient_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patient_key_;
  }
  if (patient_key) {
    set_has_patient_key();
    patient_key_ = patient_key;
  } else {
    clear_has_patient_key();
    patient_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.patient_key)
}

// required string dataset = 3;
inline bool Visit::has_dataset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Visit::set_has_dataset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Visit::clear_has_dataset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Visit::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& Visit::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dataset)
  return *dataset_;
}
inline void Visit::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.dataset)
}
inline void Visit::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.dataset)
}
inline void Visit::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.dataset)
}
inline ::std::string* Visit::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.dataset)
  return dataset_;
}
inline ::std::string* Visit::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.dataset)
}

// required string state = 4;
inline bool Visit::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Visit::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Visit::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Visit::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Visit::state() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.state)
  return *state_;
}
inline void Visit::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.state)
}
inline void Visit::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.state)
}
inline void Visit::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.state)
}
inline ::std::string* Visit::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.state)
  return state_;
}
inline ::std::string* Visit::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.state)
}

// required string facility = 5;
inline bool Visit::has_facility() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Visit::set_has_facility() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Visit::clear_has_facility() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Visit::clear_facility() {
  if (facility_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    facility_->clear();
  }
  clear_has_facility();
}
inline const ::std::string& Visit::facility() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.facility)
  return *facility_;
}
inline void Visit::set_facility(const ::std::string& value) {
  set_has_facility();
  if (facility_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    facility_ = new ::std::string;
  }
  facility_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.facility)
}
inline void Visit::set_facility(const char* value) {
  set_has_facility();
  if (facility_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    facility_ = new ::std::string;
  }
  facility_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.facility)
}
inline void Visit::set_facility(const char* value, size_t size) {
  set_has_facility();
  if (facility_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    facility_ = new ::std::string;
  }
  facility_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.facility)
}
inline ::std::string* Visit::mutable_facility() {
  set_has_facility();
  if (facility_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    facility_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.facility)
  return facility_;
}
inline ::std::string* Visit::release_facility() {
  clear_has_facility();
  if (facility_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = facility_;
    facility_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_facility(::std::string* facility) {
  if (facility_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete facility_;
  }
  if (facility) {
    set_has_facility();
    facility_ = facility;
  } else {
    clear_has_facility();
    facility_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.facility)
}

// required .comphealth.ETYPE vtype = 6;
inline bool Visit::has_vtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Visit::set_has_vtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Visit::clear_has_vtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Visit::clear_vtype() {
  vtype_ = 0;
  clear_has_vtype();
}
inline ::comphealth::ETYPE Visit::vtype() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.vtype)
  return static_cast< ::comphealth::ETYPE >(vtype_);
}
inline void Visit::set_vtype(::comphealth::ETYPE value) {
  assert(::comphealth::ETYPE_IsValid(value));
  set_has_vtype();
  vtype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.vtype)
}

// required int32 age = 7 [default = -1];
inline bool Visit::has_age() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Visit::set_has_age() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Visit::clear_has_age() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Visit::clear_age() {
  age_ = -1;
  clear_has_age();
}
inline ::google::protobuf::int32 Visit::age() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.age)
  return age_;
}
inline void Visit::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.age)
}

// required .comphealth.SEX sex = 8;
inline bool Visit::has_sex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Visit::set_has_sex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Visit::clear_has_sex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Visit::clear_sex() {
  sex_ = 10;
  clear_has_sex();
}
inline ::comphealth::SEX Visit::sex() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.sex)
  return static_cast< ::comphealth::SEX >(sex_);
}
inline void Visit::set_sex(::comphealth::SEX value) {
  assert(::comphealth::SEX_IsValid(value));
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.sex)
}

// required .comphealth.RACE race = 9;
inline bool Visit::has_race() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Visit::set_has_race() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Visit::clear_has_race() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Visit::clear_race() {
  race_ = 51;
  clear_has_race();
}
inline ::comphealth::RACE Visit::race() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.race)
  return static_cast< ::comphealth::RACE >(race_);
}
inline void Visit::set_race(::comphealth::RACE value) {
  assert(::comphealth::RACE_IsValid(value));
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.race)
}

// required .comphealth.SOURCE source = 10;
inline bool Visit::has_source() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Visit::set_has_source() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Visit::clear_has_source() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Visit::clear_source() {
  source_ = 61;
  clear_has_source();
}
inline ::comphealth::SOURCE Visit::source() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.source)
  return static_cast< ::comphealth::SOURCE >(source_);
}
inline void Visit::set_source(::comphealth::SOURCE value) {
  assert(::comphealth::SOURCE_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.source)
}

// required .comphealth.DISPOSITION disposition = 11;
inline bool Visit::has_disposition() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Visit::set_has_disposition() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Visit::clear_has_disposition() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Visit::clear_disposition() {
  disposition_ = 71;
  clear_has_disposition();
}
inline ::comphealth::DISPOSITION Visit::disposition() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.disposition)
  return static_cast< ::comphealth::DISPOSITION >(disposition_);
}
inline void Visit::set_disposition(::comphealth::DISPOSITION value) {
  assert(::comphealth::DISPOSITION_IsValid(value));
  set_has_disposition();
  disposition_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.disposition)
}

// required int32 los = 12;
inline bool Visit::has_los() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Visit::set_has_los() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Visit::clear_has_los() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Visit::clear_los() {
  los_ = 0;
  clear_has_los();
}
inline ::google::protobuf::int32 Visit::los() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.los)
  return los_;
}
inline void Visit::set_los(::google::protobuf::int32 value) {
  set_has_los();
  los_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.los)
}

// required .comphealth.DEATH death = 13;
inline bool Visit::has_death() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Visit::set_has_death() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Visit::clear_has_death() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Visit::clear_death() {
  death_ = 30;
  clear_has_death();
}
inline ::comphealth::DEATH Visit::death() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.death)
  return static_cast< ::comphealth::DEATH >(death_);
}
inline void Visit::set_death(::comphealth::DEATH value) {
  assert(::comphealth::DEATH_IsValid(value));
  set_has_death();
  death_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.death)
}

// required .comphealth.PAYER payer = 14;
inline bool Visit::has_payer() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Visit::set_has_payer() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Visit::clear_has_payer() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Visit::clear_payer() {
  payer_ = 41;
  clear_has_payer();
}
inline ::comphealth::PAYER Visit::payer() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.payer)
  return static_cast< ::comphealth::PAYER >(payer_);
}
inline void Visit::set_payer(::comphealth::PAYER value) {
  assert(::comphealth::PAYER_IsValid(value));
  set_has_payer();
  payer_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.payer)
}

// required string primary_diagnosis = 15;
inline bool Visit::has_primary_diagnosis() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Visit::set_has_primary_diagnosis() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Visit::clear_has_primary_diagnosis() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Visit::clear_primary_diagnosis() {
  if (primary_diagnosis_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_diagnosis_->clear();
  }
  clear_has_primary_diagnosis();
}
inline const ::std::string& Visit::primary_diagnosis() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.primary_diagnosis)
  return *primary_diagnosis_;
}
inline void Visit::set_primary_diagnosis(const ::std::string& value) {
  set_has_primary_diagnosis();
  if (primary_diagnosis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_diagnosis_ = new ::std::string;
  }
  primary_diagnosis_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.primary_diagnosis)
}
inline void Visit::set_primary_diagnosis(const char* value) {
  set_has_primary_diagnosis();
  if (primary_diagnosis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_diagnosis_ = new ::std::string;
  }
  primary_diagnosis_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.primary_diagnosis)
}
inline void Visit::set_primary_diagnosis(const char* value, size_t size) {
  set_has_primary_diagnosis();
  if (primary_diagnosis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_diagnosis_ = new ::std::string;
  }
  primary_diagnosis_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.primary_diagnosis)
}
inline ::std::string* Visit::mutable_primary_diagnosis() {
  set_has_primary_diagnosis();
  if (primary_diagnosis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_diagnosis_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.primary_diagnosis)
  return primary_diagnosis_;
}
inline ::std::string* Visit::release_primary_diagnosis() {
  clear_has_primary_diagnosis();
  if (primary_diagnosis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = primary_diagnosis_;
    primary_diagnosis_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_primary_diagnosis(::std::string* primary_diagnosis) {
  if (primary_diagnosis_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete primary_diagnosis_;
  }
  if (primary_diagnosis) {
    set_has_primary_diagnosis();
    primary_diagnosis_ = primary_diagnosis;
  } else {
    clear_has_primary_diagnosis();
    primary_diagnosis_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.primary_diagnosis)
}

// optional .comphealth.PR primary_procedure = 16;
inline bool Visit::has_primary_procedure() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Visit::set_has_primary_procedure() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Visit::clear_has_primary_procedure() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Visit::clear_primary_procedure() {
  if (primary_procedure_ != NULL) primary_procedure_->::comphealth::PR::Clear();
  clear_has_primary_procedure();
}
inline const ::comphealth::PR& Visit::primary_procedure() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.primary_procedure)
  return primary_procedure_ != NULL ? *primary_procedure_ : *default_instance_->primary_procedure_;
}
inline ::comphealth::PR* Visit::mutable_primary_procedure() {
  set_has_primary_procedure();
  if (primary_procedure_ == NULL) primary_procedure_ = new ::comphealth::PR;
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.primary_procedure)
  return primary_procedure_;
}
inline ::comphealth::PR* Visit::release_primary_procedure() {
  clear_has_primary_procedure();
  ::comphealth::PR* temp = primary_procedure_;
  primary_procedure_ = NULL;
  return temp;
}
inline void Visit::set_allocated_primary_procedure(::comphealth::PR* primary_procedure) {
  delete primary_procedure_;
  primary_procedure_ = primary_procedure;
  if (primary_procedure) {
    set_has_primary_procedure();
  } else {
    clear_has_primary_procedure();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.primary_procedure)
}

// required string drg = 18;
inline bool Visit::has_drg() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Visit::set_has_drg() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Visit::clear_has_drg() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Visit::clear_drg() {
  if (drg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    drg_->clear();
  }
  clear_has_drg();
}
inline const ::std::string& Visit::drg() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.drg)
  return *drg_;
}
inline void Visit::set_drg(const ::std::string& value) {
  set_has_drg();
  if (drg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    drg_ = new ::std::string;
  }
  drg_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Visit.drg)
}
inline void Visit::set_drg(const char* value) {
  set_has_drg();
  if (drg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    drg_ = new ::std::string;
  }
  drg_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.drg)
}
inline void Visit::set_drg(const char* value, size_t size) {
  set_has_drg();
  if (drg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    drg_ = new ::std::string;
  }
  drg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.drg)
}
inline ::std::string* Visit::mutable_drg() {
  set_has_drg();
  if (drg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    drg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.drg)
  return drg_;
}
inline ::std::string* Visit::release_drg() {
  clear_has_drg();
  if (drg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = drg_;
    drg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Visit::set_allocated_drg(::std::string* drg) {
  if (drg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete drg_;
  }
  if (drg) {
    set_has_drg();
    drg_ = drg;
  } else {
    clear_has_drg();
    drg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Visit.drg)
}

// repeated string dxs = 19;
inline int Visit::dxs_size() const {
  return dxs_.size();
}
inline void Visit::clear_dxs() {
  dxs_.Clear();
}
inline const ::std::string& Visit::dxs(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dxs)
  return dxs_.Get(index);
}
inline ::std::string* Visit::mutable_dxs(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.dxs)
  return dxs_.Mutable(index);
}
inline void Visit::set_dxs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:comphealth.Visit.dxs)
  dxs_.Mutable(index)->assign(value);
}
inline void Visit::set_dxs(int index, const char* value) {
  dxs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.dxs)
}
inline void Visit::set_dxs(int index, const char* value, size_t size) {
  dxs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.dxs)
}
inline ::std::string* Visit::add_dxs() {
  return dxs_.Add();
}
inline void Visit::add_dxs(const ::std::string& value) {
  dxs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:comphealth.Visit.dxs)
}
inline void Visit::add_dxs(const char* value) {
  dxs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:comphealth.Visit.dxs)
}
inline void Visit::add_dxs(const char* value, size_t size) {
  dxs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:comphealth.Visit.dxs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Visit::dxs() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.dxs)
  return dxs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Visit::mutable_dxs() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.dxs)
  return &dxs_;
}

// repeated string exs = 20;
inline int Visit::exs_size() const {
  return exs_.size();
}
inline void Visit::clear_exs() {
  exs_.Clear();
}
inline const ::std::string& Visit::exs(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.exs)
  return exs_.Get(index);
}
inline ::std::string* Visit::mutable_exs(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.exs)
  return exs_.Mutable(index);
}
inline void Visit::set_exs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:comphealth.Visit.exs)
  exs_.Mutable(index)->assign(value);
}
inline void Visit::set_exs(int index, const char* value) {
  exs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.exs)
}
inline void Visit::set_exs(int index, const char* value, size_t size) {
  exs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.exs)
}
inline ::std::string* Visit::add_exs() {
  return exs_.Add();
}
inline void Visit::add_exs(const ::std::string& value) {
  exs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:comphealth.Visit.exs)
}
inline void Visit::add_exs(const char* value) {
  exs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:comphealth.Visit.exs)
}
inline void Visit::add_exs(const char* value, size_t size) {
  exs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:comphealth.Visit.exs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Visit::exs() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.exs)
  return exs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Visit::mutable_exs() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.exs)
  return &exs_;
}

// repeated string poas = 37;
inline int Visit::poas_size() const {
  return poas_.size();
}
inline void Visit::clear_poas() {
  poas_.Clear();
}
inline const ::std::string& Visit::poas(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.poas)
  return poas_.Get(index);
}
inline ::std::string* Visit::mutable_poas(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.poas)
  return poas_.Mutable(index);
}
inline void Visit::set_poas(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:comphealth.Visit.poas)
  poas_.Mutable(index)->assign(value);
}
inline void Visit::set_poas(int index, const char* value) {
  poas_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Visit.poas)
}
inline void Visit::set_poas(int index, const char* value, size_t size) {
  poas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Visit.poas)
}
inline ::std::string* Visit::add_poas() {
  return poas_.Add();
}
inline void Visit::add_poas(const ::std::string& value) {
  poas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:comphealth.Visit.poas)
}
inline void Visit::add_poas(const char* value) {
  poas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:comphealth.Visit.poas)
}
inline void Visit::add_poas(const char* value, size_t size) {
  poas_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:comphealth.Visit.poas)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Visit::poas() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.poas)
  return poas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Visit::mutable_poas() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.poas)
  return &poas_;
}

// repeated .comphealth.PR prs = 21;
inline int Visit::prs_size() const {
  return prs_.size();
}
inline void Visit::clear_prs() {
  prs_.Clear();
}
inline const ::comphealth::PR& Visit::prs(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.prs)
  return prs_.Get(index);
}
inline ::comphealth::PR* Visit::mutable_prs(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.prs)
  return prs_.Mutable(index);
}
inline ::comphealth::PR* Visit::add_prs() {
  // @@protoc_insertion_point(field_add:comphealth.Visit.prs)
  return prs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PR >&
Visit::prs() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.prs)
  return prs_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::PR >*
Visit::mutable_prs() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.prs)
  return &prs_;
}

// required int32 year = 22;
inline bool Visit::has_year() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Visit::set_has_year() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Visit::clear_has_year() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Visit::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 Visit::year() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.year)
  return year_;
}
inline void Visit::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.year)
}

// required int32 day = 23;
inline bool Visit::has_day() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Visit::set_has_day() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Visit::clear_has_day() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Visit::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 Visit::day() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.day)
  return day_;
}
inline void Visit::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.day)
}

// required int32 month = 24 [default = -1];
inline bool Visit::has_month() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Visit::set_has_month() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Visit::clear_has_month() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Visit::clear_month() {
  month_ = -1;
  clear_has_month();
}
inline ::google::protobuf::int32 Visit::month() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.month)
  return month_;
}
inline void Visit::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.month)
}

// required int32 quarter = 26 [default = -1];
inline bool Visit::has_quarter() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Visit::set_has_quarter() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Visit::clear_has_quarter() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Visit::clear_quarter() {
  quarter_ = -1;
  clear_has_quarter();
}
inline ::google::protobuf::int32 Visit::quarter() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.quarter)
  return quarter_;
}
inline void Visit::set_quarter(::google::protobuf::int32 value) {
  set_has_quarter();
  quarter_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.quarter)
}

// required .comphealth.PZIP zip = 27;
inline bool Visit::has_zip() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Visit::set_has_zip() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Visit::clear_has_zip() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Visit::clear_zip() {
  zip_ = 101;
  clear_has_zip();
}
inline ::comphealth::PZIP Visit::zip() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.zip)
  return static_cast< ::comphealth::PZIP >(zip_);
}
inline void Visit::set_zip(::comphealth::PZIP value) {
  assert(::comphealth::PZIP_IsValid(value));
  set_has_zip();
  zip_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.zip)
}

// required .comphealth.DNR dnr = 28;
inline bool Visit::has_dnr() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Visit::set_has_dnr() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Visit::clear_has_dnr() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Visit::clear_dnr() {
  dnr_ = 80;
  clear_has_dnr();
}
inline ::comphealth::DNR Visit::dnr() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dnr)
  return static_cast< ::comphealth::DNR >(dnr_);
}
inline void Visit::set_dnr(::comphealth::DNR value) {
  assert(::comphealth::DNR_IsValid(value));
  set_has_dnr();
  dnr_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.dnr)
}

// required float charge = 30;
inline bool Visit::has_charge() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Visit::set_has_charge() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Visit::clear_has_charge() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Visit::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline float Visit::charge() const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.charge)
  return charge_;
}
inline void Visit::set_charge(float value) {
  set_has_charge();
  charge_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Visit.charge)
}

// repeated .comphealth.KVS dstring = 34;
inline int Visit::dstring_size() const {
  return dstring_.size();
}
inline void Visit::clear_dstring() {
  dstring_.Clear();
}
inline const ::comphealth::KVS& Visit::dstring(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dstring)
  return dstring_.Get(index);
}
inline ::comphealth::KVS* Visit::mutable_dstring(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.dstring)
  return dstring_.Mutable(index);
}
inline ::comphealth::KVS* Visit::add_dstring() {
  // @@protoc_insertion_point(field_add:comphealth.Visit.dstring)
  return dstring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVS >&
Visit::dstring() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.dstring)
  return dstring_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVS >*
Visit::mutable_dstring() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.dstring)
  return &dstring_;
}

// repeated .comphealth.KVI dint = 35;
inline int Visit::dint_size() const {
  return dint_.size();
}
inline void Visit::clear_dint() {
  dint_.Clear();
}
inline const ::comphealth::KVI& Visit::dint(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dint)
  return dint_.Get(index);
}
inline ::comphealth::KVI* Visit::mutable_dint(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.dint)
  return dint_.Mutable(index);
}
inline ::comphealth::KVI* Visit::add_dint() {
  // @@protoc_insertion_point(field_add:comphealth.Visit.dint)
  return dint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
Visit::dint() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.dint)
  return dint_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
Visit::mutable_dint() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.dint)
  return &dint_;
}

// repeated .comphealth.KVF dfloat = 36;
inline int Visit::dfloat_size() const {
  return dfloat_.size();
}
inline void Visit::clear_dfloat() {
  dfloat_.Clear();
}
inline const ::comphealth::KVF& Visit::dfloat(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Visit.dfloat)
  return dfloat_.Get(index);
}
inline ::comphealth::KVF* Visit::mutable_dfloat(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Visit.dfloat)
  return dfloat_.Mutable(index);
}
inline ::comphealth::KVF* Visit::add_dfloat() {
  // @@protoc_insertion_point(field_add:comphealth.Visit.dfloat)
  return dfloat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVF >&
Visit::dfloat() const {
  // @@protoc_insertion_point(field_list:comphealth.Visit.dfloat)
  return dfloat_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVF >*
Visit::mutable_dfloat() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Visit.dfloat)
  return &dfloat_;
}

// -------------------------------------------------------------------

// Patient

// optional string patient_key = 1;
inline bool Patient::has_patient_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patient::set_has_patient_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patient::clear_has_patient_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patient::clear_patient_key() {
  if (patient_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_->clear();
  }
  clear_has_patient_key();
}
inline const ::std::string& Patient::patient_key() const {
  // @@protoc_insertion_point(field_get:comphealth.Patient.patient_key)
  return *patient_key_;
}
inline void Patient::set_patient_key(const ::std::string& value) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Patient.patient_key)
}
inline void Patient::set_patient_key(const char* value) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Patient.patient_key)
}
inline void Patient::set_patient_key(const char* value, size_t size) {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  patient_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Patient.patient_key)
}
inline ::std::string* Patient::mutable_patient_key() {
  set_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patient_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Patient.patient_key)
  return patient_key_;
}
inline ::std::string* Patient::release_patient_key() {
  clear_has_patient_key();
  if (patient_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patient_key_;
    patient_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Patient::set_allocated_patient_key(::std::string* patient_key) {
  if (patient_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patient_key_;
  }
  if (patient_key) {
    set_has_patient_key();
    patient_key_ = patient_key;
  } else {
    clear_has_patient_key();
    patient_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Patient.patient_key)
}

// repeated .comphealth.Visit visits = 2;
inline int Patient::visits_size() const {
  return visits_.size();
}
inline void Patient::clear_visits() {
  visits_.Clear();
}
inline const ::comphealth::Visit& Patient::visits(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.Patient.visits)
  return visits_.Get(index);
}
inline ::comphealth::Visit* Patient::mutable_visits(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.Patient.visits)
  return visits_.Mutable(index);
}
inline ::comphealth::Visit* Patient::add_visits() {
  // @@protoc_insertion_point(field_add:comphealth.Patient.visits)
  return visits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >&
Patient::visits() const {
  // @@protoc_insertion_point(field_list:comphealth.Patient.visits)
  return visits_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >*
Patient::mutable_visits() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.Patient.visits)
  return &visits_;
}

// optional string raw = 3;
inline bool Patient::has_raw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Patient::set_has_raw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Patient::clear_has_raw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Patient::clear_raw() {
  if (raw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_->clear();
  }
  clear_has_raw();
}
inline const ::std::string& Patient::raw() const {
  // @@protoc_insertion_point(field_get:comphealth.Patient.raw)
  return *raw_;
}
inline void Patient::set_raw(const ::std::string& value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Patient.raw)
}
inline void Patient::set_raw(const char* value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Patient.raw)
}
inline void Patient::set_raw(const char* value, size_t size) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Patient.raw)
}
inline ::std::string* Patient::mutable_raw() {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Patient.raw)
  return raw_;
}
inline ::std::string* Patient::release_raw() {
  clear_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = raw_;
    raw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Patient::set_allocated_raw(::std::string* raw) {
  if (raw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete raw_;
  }
  if (raw) {
    set_has_raw();
    raw_ = raw;
  } else {
    clear_has_raw();
    raw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Patient.raw)
}

// optional bool linked = 4 [default = false];
inline bool Patient::has_linked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Patient::set_has_linked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Patient::clear_has_linked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Patient::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool Patient::linked() const {
  // @@protoc_insertion_point(field_get:comphealth.Patient.linked)
  return linked_;
}
inline void Patient::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Patient.linked)
}

// -------------------------------------------------------------------

// PatientList

// repeated .comphealth.Patient patients = 1;
inline int PatientList::patients_size() const {
  return patients_.size();
}
inline void PatientList::clear_patients() {
  patients_.Clear();
}
inline const ::comphealth::Patient& PatientList::patients(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PatientList.patients)
  return patients_.Get(index);
}
inline ::comphealth::Patient* PatientList::mutable_patients(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PatientList.patients)
  return patients_.Mutable(index);
}
inline ::comphealth::Patient* PatientList::add_patients() {
  // @@protoc_insertion_point(field_add:comphealth.PatientList.patients)
  return patients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Patient >&
PatientList::patients() const {
  // @@protoc_insertion_point(field_list:comphealth.PatientList.patients)
  return patients_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Patient >*
PatientList::mutable_patients() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PatientList.patients)
  return &patients_;
}

// -------------------------------------------------------------------

// VisitList

// repeated .comphealth.Visit visits = 1;
inline int VisitList::visits_size() const {
  return visits_.size();
}
inline void VisitList::clear_visits() {
  visits_.Clear();
}
inline const ::comphealth::Visit& VisitList::visits(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.VisitList.visits)
  return visits_.Get(index);
}
inline ::comphealth::Visit* VisitList::mutable_visits(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.VisitList.visits)
  return visits_.Mutable(index);
}
inline ::comphealth::Visit* VisitList::add_visits() {
  // @@protoc_insertion_point(field_add:comphealth.VisitList.visits)
  return visits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >&
VisitList::visits() const {
  // @@protoc_insertion_point(field_list:comphealth.VisitList.visits)
  return visits_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Visit >*
VisitList::mutable_visits() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.VisitList.visits)
  return &visits_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pvisit_2eproto__INCLUDED
