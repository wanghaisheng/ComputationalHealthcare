// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pn3.proto

#ifndef PROTOBUF_pn3_2eproto__INCLUDED
#define PROTOBUF_pn3_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "penums.pb.h"
#include "pvisit.pb.h"
#include "pstat.pb.h"
#include "pn1.pb.h"
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pn3_2eproto();
void protobuf_AssignDesc_pn3_2eproto();
void protobuf_ShutdownFile_pn3_2eproto();

class VEntry;
class VNode;

enum KEYTYPE {
  N3_ICDPR = 720,
  N3_DX = 722,
  N3_DRG = 723,
  N3_CPT = 724,
  N3_ALL = 725
};
bool KEYTYPE_IsValid(int value);
const KEYTYPE KEYTYPE_MIN = N3_ICDPR;
const KEYTYPE KEYTYPE_MAX = N3_ALL;
const int KEYTYPE_ARRAYSIZE = KEYTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* KEYTYPE_descriptor();
inline const ::std::string& KEYTYPE_Name(KEYTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    KEYTYPE_descriptor(), value);
}
inline bool KEYTYPE_Parse(
    const ::std::string& name, KEYTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KEYTYPE>(
    KEYTYPE_descriptor(), name, value);
}
// ===================================================================

class VEntry : public ::google::protobuf::Message {
 public:
  VEntry();
  virtual ~VEntry();

  VEntry(const VEntry& from);

  inline VEntry& operator=(const VEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VEntry& default_instance();

  void Swap(VEntry* other);

  // implements Message ----------------------------------------------

  VEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VEntry& from);
  void MergeFrom(const VEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 11;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 11;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string initial_key = 1;
  inline bool has_initial_key() const;
  inline void clear_initial_key();
  static const int kInitialKeyFieldNumber = 1;
  inline const ::std::string& initial_key() const;
  inline void set_initial_key(const ::std::string& value);
  inline void set_initial_key(const char* value);
  inline void set_initial_key(const char* value, size_t size);
  inline ::std::string* mutable_initial_key();
  inline ::std::string* release_initial_key();
  inline void set_allocated_initial_key(::std::string* initial_key);

  // required string sub_key = 2;
  inline bool has_sub_key() const;
  inline void clear_sub_key();
  static const int kSubKeyFieldNumber = 2;
  inline const ::std::string& sub_key() const;
  inline void set_sub_key(const ::std::string& value);
  inline void set_sub_key(const char* value);
  inline void set_sub_key(const char* value, size_t size);
  inline ::std::string* mutable_sub_key();
  inline ::std::string* release_sub_key();
  inline void set_allocated_sub_key(::std::string* sub_key);

  // optional string dataset = 3;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 3;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // optional int32 delta = 8;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 8;
  inline ::google::protobuf::int32 delta() const;
  inline void set_delta(::google::protobuf::int32 value);

  // required .comphealth.AGG initial = 4;
  inline bool has_initial() const;
  inline void clear_initial();
  static const int kInitialFieldNumber = 4;
  inline const ::comphealth::AGG& initial() const;
  inline ::comphealth::AGG* mutable_initial();
  inline ::comphealth::AGG* release_initial();
  inline void set_allocated_initial(::comphealth::AGG* initial);

  // required .comphealth.AGG sub = 5;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 5;
  inline const ::comphealth::AGG& sub() const;
  inline ::comphealth::AGG* mutable_sub();
  inline ::comphealth::AGG* release_sub();
  inline void set_allocated_sub(::comphealth::AGG* sub);

  // required .comphealth.IntHist deltah = 6;
  inline bool has_deltah() const;
  inline void clear_deltah();
  static const int kDeltahFieldNumber = 6;
  inline const ::comphealth::IntHist& deltah() const;
  inline ::comphealth::IntHist* mutable_deltah();
  inline ::comphealth::IntHist* release_deltah();
  inline void set_allocated_deltah(::comphealth::IntHist* deltah);

  // required .comphealth.IntHist deltaweekh = 12;
  inline bool has_deltaweekh() const;
  inline void clear_deltaweekh();
  static const int kDeltaweekhFieldNumber = 12;
  inline const ::comphealth::IntHist& deltaweekh() const;
  inline ::comphealth::IntHist* mutable_deltaweekh();
  inline ::comphealth::IntHist* release_deltaweekh();
  inline void set_allocated_deltaweekh(::comphealth::IntHist* deltaweekh);

  // repeated .comphealth.Exclusion provenance = 7;
  inline int provenance_size() const;
  inline void clear_provenance();
  static const int kProvenanceFieldNumber = 7;
  inline const ::comphealth::Exclusion& provenance(int index) const;
  inline ::comphealth::Exclusion* mutable_provenance(int index);
  inline ::comphealth::Exclusion* add_provenance();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
      provenance() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
      mutable_provenance();

  // required .comphealth.KEYTYPE initial_ktype = 9;
  inline bool has_initial_ktype() const;
  inline void clear_initial_ktype();
  static const int kInitialKtypeFieldNumber = 9;
  inline ::comphealth::KEYTYPE initial_ktype() const;
  inline void set_initial_ktype(::comphealth::KEYTYPE value);

  // required .comphealth.KEYTYPE sub_ktype = 10;
  inline bool has_sub_ktype() const;
  inline void clear_sub_ktype();
  static const int kSubKtypeFieldNumber = 10;
  inline ::comphealth::KEYTYPE sub_ktype() const;
  inline void set_sub_ktype(::comphealth::KEYTYPE value);

  // @@protoc_insertion_point(class_scope:comphealth.VEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_initial_key();
  inline void clear_has_initial_key();
  inline void set_has_sub_key();
  inline void clear_has_sub_key();
  inline void set_has_dataset();
  inline void clear_has_dataset();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_initial();
  inline void clear_has_initial();
  inline void set_has_sub();
  inline void clear_has_sub();
  inline void set_has_deltah();
  inline void clear_has_deltah();
  inline void set_has_deltaweekh();
  inline void clear_has_deltaweekh();
  inline void set_has_initial_ktype();
  inline void clear_has_initial_ktype();
  inline void set_has_sub_ktype();
  inline void clear_has_sub_ktype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* initial_key_;
  ::std::string* sub_key_;
  ::std::string* dataset_;
  ::comphealth::AGG* initial_;
  ::comphealth::AGG* sub_;
  ::comphealth::IntHist* deltah_;
  ::google::protobuf::int32 delta_;
  int initial_ktype_;
  ::comphealth::IntHist* deltaweekh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion > provenance_;
  int sub_ktype_;
  friend void  protobuf_AddDesc_pn3_2eproto();
  friend void protobuf_AssignDesc_pn3_2eproto();
  friend void protobuf_ShutdownFile_pn3_2eproto();

  void InitAsDefaultInstance();
  static VEntry* default_instance_;
};
// -------------------------------------------------------------------

class VNode : public ::google::protobuf::Message {
 public:
  VNode();
  virtual ~VNode();

  VNode(const VNode& from);

  inline VNode& operator=(const VNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VNode& default_instance();

  void Swap(VNode* other);

  // implements Message ----------------------------------------------

  VNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VNode& from);
  void MergeFrom(const VNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .comphealth.KEYTYPE ktype = 2;
  inline bool has_ktype() const;
  inline void clear_ktype();
  static const int kKtypeFieldNumber = 2;
  inline ::comphealth::KEYTYPE ktype() const;
  inline void set_ktype(::comphealth::KEYTYPE value);

  // optional string dataset = 3;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 3;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // required .comphealth.AGG all = 4;
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 4;
  inline const ::comphealth::AGG& all() const;
  inline ::comphealth::AGG* mutable_all();
  inline ::comphealth::AGG* release_all();
  inline void set_allocated_all(::comphealth::AGG* all);

  // optional .comphealth.AGG discharged = 5;
  inline bool has_discharged() const;
  inline void clear_discharged();
  static const int kDischargedFieldNumber = 5;
  inline const ::comphealth::AGG& discharged() const;
  inline ::comphealth::AGG* mutable_discharged();
  inline ::comphealth::AGG* release_discharged();
  inline void set_allocated_discharged(::comphealth::AGG* discharged);

  // optional .comphealth.AGG transferred = 6;
  inline bool has_transferred() const;
  inline void clear_transferred();
  static const int kTransferredFieldNumber = 6;
  inline const ::comphealth::AGG& transferred() const;
  inline ::comphealth::AGG* mutable_transferred();
  inline ::comphealth::AGG* release_transferred();
  inline void set_allocated_transferred(::comphealth::AGG* transferred);

  // optional .comphealth.AGG died = 7;
  inline bool has_died() const;
  inline void clear_died();
  static const int kDiedFieldNumber = 7;
  inline const ::comphealth::AGG& died() const;
  inline ::comphealth::AGG* mutable_died();
  inline ::comphealth::AGG* release_died();
  inline void set_allocated_died(::comphealth::AGG* died);

  // repeated .comphealth.Exclusion provenance = 8;
  inline int provenance_size() const;
  inline void clear_provenance();
  static const int kProvenanceFieldNumber = 8;
  inline const ::comphealth::Exclusion& provenance(int index) const;
  inline ::comphealth::Exclusion* mutable_provenance(int index);
  inline ::comphealth::Exclusion* add_provenance();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
      provenance() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
      mutable_provenance();

  // required bool linked = 9;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 9;
  inline bool linked() const;
  inline void set_linked(bool value);

  // @@protoc_insertion_point(class_scope:comphealth.VNode)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_ktype();
  inline void clear_has_ktype();
  inline void set_has_dataset();
  inline void clear_has_dataset();
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_discharged();
  inline void clear_has_discharged();
  inline void set_has_transferred();
  inline void clear_has_transferred();
  inline void set_has_died();
  inline void clear_has_died();
  inline void set_has_linked();
  inline void clear_has_linked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* dataset_;
  ::comphealth::AGG* all_;
  ::comphealth::AGG* discharged_;
  int ktype_;
  bool linked_;
  ::comphealth::AGG* transferred_;
  ::comphealth::AGG* died_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion > provenance_;
  friend void  protobuf_AddDesc_pn3_2eproto();
  friend void protobuf_AssignDesc_pn3_2eproto();
  friend void protobuf_ShutdownFile_pn3_2eproto();

  void InitAsDefaultInstance();
  static VNode* default_instance_;
};
// ===================================================================


// ===================================================================

// VEntry

// required string key = 11;
inline bool VEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& VEntry::key() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.key)
  return *key_;
}
inline void VEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VEntry.key)
}
inline void VEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VEntry.key)
}
inline void VEntry::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VEntry.key)
}
inline ::std::string* VEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.key)
  return key_;
}
inline ::std::string* VEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.key)
}

// required string initial_key = 1;
inline bool VEntry::has_initial_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VEntry::set_has_initial_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VEntry::clear_has_initial_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VEntry::clear_initial_key() {
  if (initial_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_key_->clear();
  }
  clear_has_initial_key();
}
inline const ::std::string& VEntry::initial_key() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.initial_key)
  return *initial_key_;
}
inline void VEntry::set_initial_key(const ::std::string& value) {
  set_has_initial_key();
  if (initial_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_key_ = new ::std::string;
  }
  initial_key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VEntry.initial_key)
}
inline void VEntry::set_initial_key(const char* value) {
  set_has_initial_key();
  if (initial_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_key_ = new ::std::string;
  }
  initial_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VEntry.initial_key)
}
inline void VEntry::set_initial_key(const char* value, size_t size) {
  set_has_initial_key();
  if (initial_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_key_ = new ::std::string;
  }
  initial_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VEntry.initial_key)
}
inline ::std::string* VEntry::mutable_initial_key() {
  set_has_initial_key();
  if (initial_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.initial_key)
  return initial_key_;
}
inline ::std::string* VEntry::release_initial_key() {
  clear_has_initial_key();
  if (initial_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = initial_key_;
    initial_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VEntry::set_allocated_initial_key(::std::string* initial_key) {
  if (initial_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete initial_key_;
  }
  if (initial_key) {
    set_has_initial_key();
    initial_key_ = initial_key;
  } else {
    clear_has_initial_key();
    initial_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.initial_key)
}

// required string sub_key = 2;
inline bool VEntry::has_sub_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VEntry::set_has_sub_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VEntry::clear_has_sub_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VEntry::clear_sub_key() {
  if (sub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_key_->clear();
  }
  clear_has_sub_key();
}
inline const ::std::string& VEntry::sub_key() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.sub_key)
  return *sub_key_;
}
inline void VEntry::set_sub_key(const ::std::string& value) {
  set_has_sub_key();
  if (sub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_key_ = new ::std::string;
  }
  sub_key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VEntry.sub_key)
}
inline void VEntry::set_sub_key(const char* value) {
  set_has_sub_key();
  if (sub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_key_ = new ::std::string;
  }
  sub_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VEntry.sub_key)
}
inline void VEntry::set_sub_key(const char* value, size_t size) {
  set_has_sub_key();
  if (sub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_key_ = new ::std::string;
  }
  sub_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VEntry.sub_key)
}
inline ::std::string* VEntry::mutable_sub_key() {
  set_has_sub_key();
  if (sub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.sub_key)
  return sub_key_;
}
inline ::std::string* VEntry::release_sub_key() {
  clear_has_sub_key();
  if (sub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sub_key_;
    sub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VEntry::set_allocated_sub_key(::std::string* sub_key) {
  if (sub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sub_key_;
  }
  if (sub_key) {
    set_has_sub_key();
    sub_key_ = sub_key;
  } else {
    clear_has_sub_key();
    sub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.sub_key)
}

// optional string dataset = 3;
inline bool VEntry::has_dataset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VEntry::set_has_dataset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VEntry::clear_has_dataset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VEntry::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& VEntry::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.dataset)
  return *dataset_;
}
inline void VEntry::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VEntry.dataset)
}
inline void VEntry::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VEntry.dataset)
}
inline void VEntry::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VEntry.dataset)
}
inline ::std::string* VEntry::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.dataset)
  return dataset_;
}
inline ::std::string* VEntry::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VEntry::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.dataset)
}

// optional int32 delta = 8;
inline bool VEntry::has_delta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VEntry::set_has_delta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VEntry::clear_has_delta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VEntry::clear_delta() {
  delta_ = 0;
  clear_has_delta();
}
inline ::google::protobuf::int32 VEntry::delta() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.delta)
  return delta_;
}
inline void VEntry::set_delta(::google::protobuf::int32 value) {
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VEntry.delta)
}

// required .comphealth.AGG initial = 4;
inline bool VEntry::has_initial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VEntry::set_has_initial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VEntry::clear_has_initial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VEntry::clear_initial() {
  if (initial_ != NULL) initial_->::comphealth::AGG::Clear();
  clear_has_initial();
}
inline const ::comphealth::AGG& VEntry::initial() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.initial)
  return initial_ != NULL ? *initial_ : *default_instance_->initial_;
}
inline ::comphealth::AGG* VEntry::mutable_initial() {
  set_has_initial();
  if (initial_ == NULL) initial_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.initial)
  return initial_;
}
inline ::comphealth::AGG* VEntry::release_initial() {
  clear_has_initial();
  ::comphealth::AGG* temp = initial_;
  initial_ = NULL;
  return temp;
}
inline void VEntry::set_allocated_initial(::comphealth::AGG* initial) {
  delete initial_;
  initial_ = initial;
  if (initial) {
    set_has_initial();
  } else {
    clear_has_initial();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.initial)
}

// required .comphealth.AGG sub = 5;
inline bool VEntry::has_sub() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VEntry::set_has_sub() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VEntry::clear_has_sub() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VEntry::clear_sub() {
  if (sub_ != NULL) sub_->::comphealth::AGG::Clear();
  clear_has_sub();
}
inline const ::comphealth::AGG& VEntry::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.sub)
  return sub_ != NULL ? *sub_ : *default_instance_->sub_;
}
inline ::comphealth::AGG* VEntry::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) sub_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.sub)
  return sub_;
}
inline ::comphealth::AGG* VEntry::release_sub() {
  clear_has_sub();
  ::comphealth::AGG* temp = sub_;
  sub_ = NULL;
  return temp;
}
inline void VEntry::set_allocated_sub(::comphealth::AGG* sub) {
  delete sub_;
  sub_ = sub;
  if (sub) {
    set_has_sub();
  } else {
    clear_has_sub();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.sub)
}

// required .comphealth.IntHist deltah = 6;
inline bool VEntry::has_deltah() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VEntry::set_has_deltah() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VEntry::clear_has_deltah() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VEntry::clear_deltah() {
  if (deltah_ != NULL) deltah_->::comphealth::IntHist::Clear();
  clear_has_deltah();
}
inline const ::comphealth::IntHist& VEntry::deltah() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.deltah)
  return deltah_ != NULL ? *deltah_ : *default_instance_->deltah_;
}
inline ::comphealth::IntHist* VEntry::mutable_deltah() {
  set_has_deltah();
  if (deltah_ == NULL) deltah_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.deltah)
  return deltah_;
}
inline ::comphealth::IntHist* VEntry::release_deltah() {
  clear_has_deltah();
  ::comphealth::IntHist* temp = deltah_;
  deltah_ = NULL;
  return temp;
}
inline void VEntry::set_allocated_deltah(::comphealth::IntHist* deltah) {
  delete deltah_;
  deltah_ = deltah;
  if (deltah) {
    set_has_deltah();
  } else {
    clear_has_deltah();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.deltah)
}

// required .comphealth.IntHist deltaweekh = 12;
inline bool VEntry::has_deltaweekh() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VEntry::set_has_deltaweekh() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VEntry::clear_has_deltaweekh() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VEntry::clear_deltaweekh() {
  if (deltaweekh_ != NULL) deltaweekh_->::comphealth::IntHist::Clear();
  clear_has_deltaweekh();
}
inline const ::comphealth::IntHist& VEntry::deltaweekh() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.deltaweekh)
  return deltaweekh_ != NULL ? *deltaweekh_ : *default_instance_->deltaweekh_;
}
inline ::comphealth::IntHist* VEntry::mutable_deltaweekh() {
  set_has_deltaweekh();
  if (deltaweekh_ == NULL) deltaweekh_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.deltaweekh)
  return deltaweekh_;
}
inline ::comphealth::IntHist* VEntry::release_deltaweekh() {
  clear_has_deltaweekh();
  ::comphealth::IntHist* temp = deltaweekh_;
  deltaweekh_ = NULL;
  return temp;
}
inline void VEntry::set_allocated_deltaweekh(::comphealth::IntHist* deltaweekh) {
  delete deltaweekh_;
  deltaweekh_ = deltaweekh;
  if (deltaweekh) {
    set_has_deltaweekh();
  } else {
    clear_has_deltaweekh();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VEntry.deltaweekh)
}

// repeated .comphealth.Exclusion provenance = 7;
inline int VEntry::provenance_size() const {
  return provenance_.size();
}
inline void VEntry::clear_provenance() {
  provenance_.Clear();
}
inline const ::comphealth::Exclusion& VEntry::provenance(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.provenance)
  return provenance_.Get(index);
}
inline ::comphealth::Exclusion* VEntry::mutable_provenance(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.VEntry.provenance)
  return provenance_.Mutable(index);
}
inline ::comphealth::Exclusion* VEntry::add_provenance() {
  // @@protoc_insertion_point(field_add:comphealth.VEntry.provenance)
  return provenance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
VEntry::provenance() const {
  // @@protoc_insertion_point(field_list:comphealth.VEntry.provenance)
  return provenance_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
VEntry::mutable_provenance() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.VEntry.provenance)
  return &provenance_;
}

// required .comphealth.KEYTYPE initial_ktype = 9;
inline bool VEntry::has_initial_ktype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VEntry::set_has_initial_ktype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VEntry::clear_has_initial_ktype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VEntry::clear_initial_ktype() {
  initial_ktype_ = 720;
  clear_has_initial_ktype();
}
inline ::comphealth::KEYTYPE VEntry::initial_ktype() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.initial_ktype)
  return static_cast< ::comphealth::KEYTYPE >(initial_ktype_);
}
inline void VEntry::set_initial_ktype(::comphealth::KEYTYPE value) {
  assert(::comphealth::KEYTYPE_IsValid(value));
  set_has_initial_ktype();
  initial_ktype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VEntry.initial_ktype)
}

// required .comphealth.KEYTYPE sub_ktype = 10;
inline bool VEntry::has_sub_ktype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VEntry::set_has_sub_ktype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VEntry::clear_has_sub_ktype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VEntry::clear_sub_ktype() {
  sub_ktype_ = 720;
  clear_has_sub_ktype();
}
inline ::comphealth::KEYTYPE VEntry::sub_ktype() const {
  // @@protoc_insertion_point(field_get:comphealth.VEntry.sub_ktype)
  return static_cast< ::comphealth::KEYTYPE >(sub_ktype_);
}
inline void VEntry::set_sub_ktype(::comphealth::KEYTYPE value) {
  assert(::comphealth::KEYTYPE_IsValid(value));
  set_has_sub_ktype();
  sub_ktype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VEntry.sub_ktype)
}

// -------------------------------------------------------------------

// VNode

// required string key = 1;
inline bool VNode::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VNode::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VNode::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VNode::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& VNode::key() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.key)
  return *key_;
}
inline void VNode::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VNode.key)
}
inline void VNode::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VNode.key)
}
inline void VNode::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VNode.key)
}
inline ::std::string* VNode::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.key)
  return key_;
}
inline ::std::string* VNode::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VNode::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.key)
}

// required .comphealth.KEYTYPE ktype = 2;
inline bool VNode::has_ktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VNode::set_has_ktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VNode::clear_has_ktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VNode::clear_ktype() {
  ktype_ = 720;
  clear_has_ktype();
}
inline ::comphealth::KEYTYPE VNode::ktype() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.ktype)
  return static_cast< ::comphealth::KEYTYPE >(ktype_);
}
inline void VNode::set_ktype(::comphealth::KEYTYPE value) {
  assert(::comphealth::KEYTYPE_IsValid(value));
  set_has_ktype();
  ktype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VNode.ktype)
}

// optional string dataset = 3;
inline bool VNode::has_dataset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VNode::set_has_dataset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VNode::clear_has_dataset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VNode::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& VNode::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.dataset)
  return *dataset_;
}
inline void VNode::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.VNode.dataset)
}
inline void VNode::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.VNode.dataset)
}
inline void VNode::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.VNode.dataset)
}
inline ::std::string* VNode::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.dataset)
  return dataset_;
}
inline ::std::string* VNode::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VNode::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.dataset)
}

// required .comphealth.AGG all = 4;
inline bool VNode::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VNode::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VNode::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VNode::clear_all() {
  if (all_ != NULL) all_->::comphealth::AGG::Clear();
  clear_has_all();
}
inline const ::comphealth::AGG& VNode::all() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.all)
  return all_ != NULL ? *all_ : *default_instance_->all_;
}
inline ::comphealth::AGG* VNode::mutable_all() {
  set_has_all();
  if (all_ == NULL) all_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.all)
  return all_;
}
inline ::comphealth::AGG* VNode::release_all() {
  clear_has_all();
  ::comphealth::AGG* temp = all_;
  all_ = NULL;
  return temp;
}
inline void VNode::set_allocated_all(::comphealth::AGG* all) {
  delete all_;
  all_ = all;
  if (all) {
    set_has_all();
  } else {
    clear_has_all();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.all)
}

// optional .comphealth.AGG discharged = 5;
inline bool VNode::has_discharged() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VNode::set_has_discharged() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VNode::clear_has_discharged() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VNode::clear_discharged() {
  if (discharged_ != NULL) discharged_->::comphealth::AGG::Clear();
  clear_has_discharged();
}
inline const ::comphealth::AGG& VNode::discharged() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.discharged)
  return discharged_ != NULL ? *discharged_ : *default_instance_->discharged_;
}
inline ::comphealth::AGG* VNode::mutable_discharged() {
  set_has_discharged();
  if (discharged_ == NULL) discharged_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.discharged)
  return discharged_;
}
inline ::comphealth::AGG* VNode::release_discharged() {
  clear_has_discharged();
  ::comphealth::AGG* temp = discharged_;
  discharged_ = NULL;
  return temp;
}
inline void VNode::set_allocated_discharged(::comphealth::AGG* discharged) {
  delete discharged_;
  discharged_ = discharged;
  if (discharged) {
    set_has_discharged();
  } else {
    clear_has_discharged();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.discharged)
}

// optional .comphealth.AGG transferred = 6;
inline bool VNode::has_transferred() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VNode::set_has_transferred() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VNode::clear_has_transferred() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VNode::clear_transferred() {
  if (transferred_ != NULL) transferred_->::comphealth::AGG::Clear();
  clear_has_transferred();
}
inline const ::comphealth::AGG& VNode::transferred() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.transferred)
  return transferred_ != NULL ? *transferred_ : *default_instance_->transferred_;
}
inline ::comphealth::AGG* VNode::mutable_transferred() {
  set_has_transferred();
  if (transferred_ == NULL) transferred_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.transferred)
  return transferred_;
}
inline ::comphealth::AGG* VNode::release_transferred() {
  clear_has_transferred();
  ::comphealth::AGG* temp = transferred_;
  transferred_ = NULL;
  return temp;
}
inline void VNode::set_allocated_transferred(::comphealth::AGG* transferred) {
  delete transferred_;
  transferred_ = transferred;
  if (transferred) {
    set_has_transferred();
  } else {
    clear_has_transferred();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.transferred)
}

// optional .comphealth.AGG died = 7;
inline bool VNode::has_died() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VNode::set_has_died() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VNode::clear_has_died() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VNode::clear_died() {
  if (died_ != NULL) died_->::comphealth::AGG::Clear();
  clear_has_died();
}
inline const ::comphealth::AGG& VNode::died() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.died)
  return died_ != NULL ? *died_ : *default_instance_->died_;
}
inline ::comphealth::AGG* VNode::mutable_died() {
  set_has_died();
  if (died_ == NULL) died_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.died)
  return died_;
}
inline ::comphealth::AGG* VNode::release_died() {
  clear_has_died();
  ::comphealth::AGG* temp = died_;
  died_ = NULL;
  return temp;
}
inline void VNode::set_allocated_died(::comphealth::AGG* died) {
  delete died_;
  died_ = died;
  if (died) {
    set_has_died();
  } else {
    clear_has_died();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.VNode.died)
}

// repeated .comphealth.Exclusion provenance = 8;
inline int VNode::provenance_size() const {
  return provenance_.size();
}
inline void VNode::clear_provenance() {
  provenance_.Clear();
}
inline const ::comphealth::Exclusion& VNode::provenance(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.provenance)
  return provenance_.Get(index);
}
inline ::comphealth::Exclusion* VNode::mutable_provenance(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.VNode.provenance)
  return provenance_.Mutable(index);
}
inline ::comphealth::Exclusion* VNode::add_provenance() {
  // @@protoc_insertion_point(field_add:comphealth.VNode.provenance)
  return provenance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
VNode::provenance() const {
  // @@protoc_insertion_point(field_list:comphealth.VNode.provenance)
  return provenance_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
VNode::mutable_provenance() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.VNode.provenance)
  return &provenance_;
}

// required bool linked = 9;
inline bool VNode::has_linked() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VNode::set_has_linked() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VNode::clear_has_linked() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VNode::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool VNode::linked() const {
  // @@protoc_insertion_point(field_get:comphealth.VNode.linked)
  return linked_;
}
inline void VNode::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VNode.linked)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::comphealth::KEYTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::KEYTYPE>() {
  return ::comphealth::KEYTYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pn3_2eproto__INCLUDED
