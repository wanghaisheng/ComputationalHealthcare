// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pn1.proto

#ifndef PROTOBUF_pn1_2eproto__INCLUDED
#define PROTOBUF_pn1_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "penums.pb.h"
#include "pvisit.pb.h"
#include "pstat.pb.h"
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pn1_2eproto();
void protobuf_AssignDesc_pn1_2eproto();
void protobuf_ShutdownFile_pn1_2eproto();

class PGroup;
class PEntry;
class Exclusion;
class ISubset;
class SSubset;
class RSEntry;
class PLVisits;
class PLVisit;

enum ENTRYTYPE {
  NONE = 1,
  DX = 2,
  DRG = 3
};
bool ENTRYTYPE_IsValid(int value);
const ENTRYTYPE ENTRYTYPE_MIN = NONE;
const ENTRYTYPE ENTRYTYPE_MAX = DRG;
const int ENTRYTYPE_ARRAYSIZE = ENTRYTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTRYTYPE_descriptor();
inline const ::std::string& ENTRYTYPE_Name(ENTRYTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTRYTYPE_descriptor(), value);
}
inline bool ENTRYTYPE_Parse(
    const ::std::string& name, ENTRYTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTRYTYPE>(
    ENTRYTYPE_descriptor(), name, value);
}
// ===================================================================

class PGroup : public ::google::protobuf::Message {
 public:
  PGroup();
  virtual ~PGroup();

  PGroup(const PGroup& from);

  inline PGroup& operator=(const PGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PGroup& default_instance();

  void Swap(PGroup* other);

  // implements Message ----------------------------------------------

  PGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PGroup& from);
  void MergeFrom(const PGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string primary_entry_key = 2;
  inline bool has_primary_entry_key() const;
  inline void clear_primary_entry_key();
  static const int kPrimaryEntryKeyFieldNumber = 2;
  inline const ::std::string& primary_entry_key() const;
  inline void set_primary_entry_key(const ::std::string& value);
  inline void set_primary_entry_key(const char* value);
  inline void set_primary_entry_key(const char* value, size_t size);
  inline ::std::string* mutable_primary_entry_key();
  inline ::std::string* release_primary_entry_key();
  inline void set_allocated_primary_entry_key(::std::string* primary_entry_key);

  // repeated string keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const char* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional string s = 4;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 4;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // optional int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.PGroup)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_primary_entry_key();
  inline void clear_has_primary_entry_key();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* primary_entry_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::std::string* s_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static PGroup* default_instance_;
};
// -------------------------------------------------------------------

class PEntry : public ::google::protobuf::Message {
 public:
  PEntry();
  virtual ~PEntry();

  PEntry(const PEntry& from);

  inline PEntry& operator=(const PEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PEntry& default_instance();

  void Swap(PEntry* other);

  // implements Message ----------------------------------------------

  PEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PEntry& from);
  void MergeFrom(const PEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string dataset = 2;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 2;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // required .comphealth.ENTRYTYPE etype = 3;
  inline bool has_etype() const;
  inline void clear_etype();
  static const int kEtypeFieldNumber = 3;
  inline ::comphealth::ENTRYTYPE etype() const;
  inline void set_etype(::comphealth::ENTRYTYPE value);

  // required string dx = 4;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 4;
  inline const ::std::string& dx() const;
  inline void set_dx(const ::std::string& value);
  inline void set_dx(const char* value);
  inline void set_dx(const char* value, size_t size);
  inline ::std::string* mutable_dx();
  inline ::std::string* release_dx();
  inline void set_allocated_dx(::std::string* dx);

  // required string initial = 5;
  inline bool has_initial() const;
  inline void clear_initial();
  static const int kInitialFieldNumber = 5;
  inline const ::std::string& initial() const;
  inline void set_initial(const ::std::string& value);
  inline void set_initial(const char* value);
  inline void set_initial(const char* value, size_t size);
  inline ::std::string* mutable_initial();
  inline ::std::string* release_initial();
  inline void set_allocated_initial(::std::string* initial);

  // required string sub = 6;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 6;
  inline const ::std::string& sub() const;
  inline void set_sub(const ::std::string& value);
  inline void set_sub(const char* value);
  inline void set_sub(const char* value, size_t size);
  inline ::std::string* mutable_sub();
  inline ::std::string* release_sub();
  inline void set_allocated_sub(::std::string* sub);

  // required .comphealth.IntHist deltah = 7;
  inline bool has_deltah() const;
  inline void clear_deltah();
  static const int kDeltahFieldNumber = 7;
  inline const ::comphealth::IntHist& deltah() const;
  inline ::comphealth::IntHist* mutable_deltah();
  inline ::comphealth::IntHist* release_deltah();
  inline void set_allocated_deltah(::comphealth::IntHist* deltah);

  // required .comphealth.AGG stats = 8;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 8;
  inline const ::comphealth::AGG& stats() const;
  inline ::comphealth::AGG* mutable_stats();
  inline ::comphealth::AGG* release_stats();
  inline void set_allocated_stats(::comphealth::AGG* stats);

  // repeated .comphealth.ISubset delta_subset = 9;
  inline int delta_subset_size() const;
  inline void clear_delta_subset();
  static const int kDeltaSubsetFieldNumber = 9;
  inline const ::comphealth::ISubset& delta_subset(int index) const;
  inline ::comphealth::ISubset* mutable_delta_subset(int index);
  inline ::comphealth::ISubset* add_delta_subset();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >&
      delta_subset() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >*
      mutable_delta_subset();

  // repeated .comphealth.SSubset age_subset = 10;
  inline int age_subset_size() const;
  inline void clear_age_subset();
  static const int kAgeSubsetFieldNumber = 10;
  inline const ::comphealth::SSubset& age_subset(int index) const;
  inline ::comphealth::SSubset* mutable_age_subset(int index);
  inline ::comphealth::SSubset* add_age_subset();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SSubset >&
      age_subset() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::SSubset >*
      mutable_age_subset();

  // repeated .comphealth.ISubset year_subset = 11;
  inline int year_subset_size() const;
  inline void clear_year_subset();
  static const int kYearSubsetFieldNumber = 11;
  inline const ::comphealth::ISubset& year_subset(int index) const;
  inline ::comphealth::ISubset* mutable_year_subset(int index);
  inline ::comphealth::ISubset* add_year_subset();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >&
      year_subset() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >*
      mutable_year_subset();

  // repeated .comphealth.RSEntry state_subset = 12;
  inline int state_subset_size() const;
  inline void clear_state_subset();
  static const int kStateSubsetFieldNumber = 12;
  inline const ::comphealth::RSEntry& state_subset(int index) const;
  inline ::comphealth::RSEntry* mutable_state_subset(int index);
  inline ::comphealth::RSEntry* add_state_subset();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::RSEntry >&
      state_subset() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::RSEntry >*
      mutable_state_subset();

  // optional string dataset_s = 16;
  inline bool has_dataset_s() const;
  inline void clear_dataset_s();
  static const int kDatasetSFieldNumber = 16;
  inline const ::std::string& dataset_s() const;
  inline void set_dataset_s(const ::std::string& value);
  inline void set_dataset_s(const char* value);
  inline void set_dataset_s(const char* value, size_t size);
  inline ::std::string* mutable_dataset_s();
  inline ::std::string* release_dataset_s();
  inline void set_allocated_dataset_s(::std::string* dataset_s);

  // repeated .comphealth.Exclusion provenance = 17;
  inline int provenance_size() const;
  inline void clear_provenance();
  static const int kProvenanceFieldNumber = 17;
  inline const ::comphealth::Exclusion& provenance(int index) const;
  inline ::comphealth::Exclusion* mutable_provenance(int index);
  inline ::comphealth::Exclusion* add_provenance();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
      provenance() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
      mutable_provenance();

  // optional bool pediatric = 18 [default = false];
  inline bool has_pediatric() const;
  inline void clear_pediatric();
  static const int kPediatricFieldNumber = 18;
  inline bool pediatric() const;
  inline void set_pediatric(bool value);

  // @@protoc_insertion_point(class_scope:comphealth.PEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_dataset();
  inline void clear_has_dataset();
  inline void set_has_etype();
  inline void clear_has_etype();
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_initial();
  inline void clear_has_initial();
  inline void set_has_sub();
  inline void clear_has_sub();
  inline void set_has_deltah();
  inline void clear_has_deltah();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_dataset_s();
  inline void clear_has_dataset_s();
  inline void set_has_pediatric();
  inline void clear_has_pediatric();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* dataset_;
  ::std::string* dx_;
  ::std::string* initial_;
  ::std::string* sub_;
  ::comphealth::IntHist* deltah_;
  ::comphealth::AGG* stats_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset > delta_subset_;
  int etype_;
  bool pediatric_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::SSubset > age_subset_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset > year_subset_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::RSEntry > state_subset_;
  ::std::string* dataset_s_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion > provenance_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static PEntry* default_instance_;
};
// -------------------------------------------------------------------

class Exclusion : public ::google::protobuf::Message {
 public:
  Exclusion();
  virtual ~Exclusion();

  Exclusion(const Exclusion& from);

  inline Exclusion& operator=(const Exclusion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exclusion& default_instance();

  void Swap(Exclusion* other);

  // implements Message ----------------------------------------------

  Exclusion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exclusion& from);
  void MergeFrom(const Exclusion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::google::protobuf::int32 k() const;
  inline void set_k(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.Exclusion)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* s_;
  ::google::protobuf::int32 k_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static Exclusion* default_instance_;
};
// -------------------------------------------------------------------

class ISubset : public ::google::protobuf::Message {
 public:
  ISubset();
  virtual ~ISubset();

  ISubset(const ISubset& from);

  inline ISubset& operator=(const ISubset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ISubset& default_instance();

  void Swap(ISubset* other);

  // implements Message ----------------------------------------------

  ISubset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ISubset& from);
  void MergeFrom(const ISubset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::google::protobuf::int32 k() const;
  inline void set_k(::google::protobuf::int32 value);

  // required .comphealth.AGG subset = 2;
  inline bool has_subset() const;
  inline void clear_subset();
  static const int kSubsetFieldNumber = 2;
  inline const ::comphealth::AGG& subset() const;
  inline ::comphealth::AGG* mutable_subset();
  inline ::comphealth::AGG* release_subset();
  inline void set_allocated_subset(::comphealth::AGG* subset);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.ISubset)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_subset();
  inline void clear_has_subset();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::comphealth::AGG* subset_;
  ::std::string* s_;
  ::google::protobuf::int32 k_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static ISubset* default_instance_;
};
// -------------------------------------------------------------------

class SSubset : public ::google::protobuf::Message {
 public:
  SSubset();
  virtual ~SSubset();

  SSubset(const SSubset& from);

  inline SSubset& operator=(const SSubset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSubset& default_instance();

  void Swap(SSubset* other);

  // implements Message ----------------------------------------------

  SSubset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSubset& from);
  void MergeFrom(const SSubset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // required .comphealth.AGG subset = 2;
  inline bool has_subset() const;
  inline void clear_subset();
  static const int kSubsetFieldNumber = 2;
  inline const ::comphealth::AGG& subset() const;
  inline ::comphealth::AGG* mutable_subset();
  inline ::comphealth::AGG* release_subset();
  inline void set_allocated_subset(::comphealth::AGG* subset);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.SSubset)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_subset();
  inline void clear_has_subset();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::comphealth::AGG* subset_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static SSubset* default_instance_;
};
// -------------------------------------------------------------------

class RSEntry : public ::google::protobuf::Message {
 public:
  RSEntry();
  virtual ~RSEntry();

  RSEntry(const RSEntry& from);

  inline RSEntry& operator=(const RSEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSEntry& default_instance();

  void Swap(RSEntry* other);

  // implements Message ----------------------------------------------

  RSEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RSEntry& from);
  void MergeFrom(const RSEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // required .comphealth.PEntry subset = 2;
  inline bool has_subset() const;
  inline void clear_subset();
  static const int kSubsetFieldNumber = 2;
  inline const ::comphealth::PEntry& subset() const;
  inline ::comphealth::PEntry* mutable_subset();
  inline ::comphealth::PEntry* release_subset();
  inline void set_allocated_subset(::comphealth::PEntry* subset);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.RSEntry)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_subset();
  inline void clear_has_subset();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::comphealth::PEntry* subset_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static RSEntry* default_instance_;
};
// -------------------------------------------------------------------

class PLVisits : public ::google::protobuf::Message {
 public:
  PLVisits();
  virtual ~PLVisits();

  PLVisits(const PLVisits& from);

  inline PLVisits& operator=(const PLVisits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PLVisits& default_instance();

  void Swap(PLVisits* other);

  // implements Message ----------------------------------------------

  PLVisits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PLVisits& from);
  void MergeFrom(const PLVisits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .comphealth.PLVisit plvisits = 1;
  inline int plvisits_size() const;
  inline void clear_plvisits();
  static const int kPlvisitsFieldNumber = 1;
  inline const ::comphealth::PLVisit& plvisits(int index) const;
  inline ::comphealth::PLVisit* mutable_plvisits(int index);
  inline ::comphealth::PLVisit* add_plvisits();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PLVisit >&
      plvisits() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::PLVisit >*
      mutable_plvisits();

  // @@protoc_insertion_point(class_scope:comphealth.PLVisits)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::PLVisit > plvisits_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static PLVisits* default_instance_;
};
// -------------------------------------------------------------------

class PLVisit : public ::google::protobuf::Message {
 public:
  PLVisit();
  virtual ~PLVisit();

  PLVisit(const PLVisit& from);

  inline PLVisit& operator=(const PLVisit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PLVisit& default_instance();

  void Swap(PLVisit* other);

  // implements Message ----------------------------------------------

  PLVisit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PLVisit& from);
  void MergeFrom(const PLVisit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline const ::std::string& dx() const;
  inline void set_dx(const ::std::string& value);
  inline void set_dx(const char* value);
  inline void set_dx(const char* value, size_t size);
  inline ::std::string* mutable_dx();
  inline ::std::string* release_dx();
  inline void set_allocated_dx(::std::string* dx);

  // required string initial = 2;
  inline bool has_initial() const;
  inline void clear_initial();
  static const int kInitialFieldNumber = 2;
  inline const ::std::string& initial() const;
  inline void set_initial(const ::std::string& value);
  inline void set_initial(const char* value);
  inline void set_initial(const char* value, size_t size);
  inline ::std::string* mutable_initial();
  inline ::std::string* release_initial();
  inline void set_allocated_initial(::std::string* initial);

  // required string sub = 3;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 3;
  inline const ::std::string& sub() const;
  inline void set_sub(const ::std::string& value);
  inline void set_sub(const char* value);
  inline void set_sub(const char* value, size_t size);
  inline ::std::string* mutable_sub();
  inline ::std::string* release_sub();
  inline void set_allocated_sub(::std::string* sub);

  // required int32 delta = 4;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 4;
  inline ::google::protobuf::int32 delta() const;
  inline void set_delta(::google::protobuf::int32 value);

  // required .comphealth.Visit v = 5;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 5;
  inline const ::comphealth::Visit& v() const;
  inline ::comphealth::Visit* mutable_v();
  inline ::comphealth::Visit* release_v();
  inline void set_allocated_v(::comphealth::Visit* v);

  // @@protoc_insertion_point(class_scope:comphealth.PLVisit)
 private:
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_initial();
  inline void clear_has_initial();
  inline void set_has_sub();
  inline void clear_has_sub();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* dx_;
  ::std::string* initial_;
  ::std::string* sub_;
  ::comphealth::Visit* v_;
  ::google::protobuf::int32 delta_;
  friend void  protobuf_AddDesc_pn1_2eproto();
  friend void protobuf_AssignDesc_pn1_2eproto();
  friend void protobuf_ShutdownFile_pn1_2eproto();

  void InitAsDefaultInstance();
  static PLVisit* default_instance_;
};
// ===================================================================


// ===================================================================

// PGroup

// required string key = 1;
inline bool PGroup::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PGroup::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PGroup::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PGroup::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PGroup::key() const {
  // @@protoc_insertion_point(field_get:comphealth.PGroup.key)
  return *key_;
}
inline void PGroup::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PGroup.key)
}
inline void PGroup::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PGroup.key)
}
inline void PGroup::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PGroup.key)
}
inline ::std::string* PGroup::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PGroup.key)
  return key_;
}
inline ::std::string* PGroup::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PGroup::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PGroup.key)
}

// optional string primary_entry_key = 2;
inline bool PGroup::has_primary_entry_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PGroup::set_has_primary_entry_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PGroup::clear_has_primary_entry_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PGroup::clear_primary_entry_key() {
  if (primary_entry_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_entry_key_->clear();
  }
  clear_has_primary_entry_key();
}
inline const ::std::string& PGroup::primary_entry_key() const {
  // @@protoc_insertion_point(field_get:comphealth.PGroup.primary_entry_key)
  return *primary_entry_key_;
}
inline void PGroup::set_primary_entry_key(const ::std::string& value) {
  set_has_primary_entry_key();
  if (primary_entry_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_entry_key_ = new ::std::string;
  }
  primary_entry_key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PGroup.primary_entry_key)
}
inline void PGroup::set_primary_entry_key(const char* value) {
  set_has_primary_entry_key();
  if (primary_entry_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_entry_key_ = new ::std::string;
  }
  primary_entry_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PGroup.primary_entry_key)
}
inline void PGroup::set_primary_entry_key(const char* value, size_t size) {
  set_has_primary_entry_key();
  if (primary_entry_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_entry_key_ = new ::std::string;
  }
  primary_entry_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PGroup.primary_entry_key)
}
inline ::std::string* PGroup::mutable_primary_entry_key() {
  set_has_primary_entry_key();
  if (primary_entry_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_entry_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PGroup.primary_entry_key)
  return primary_entry_key_;
}
inline ::std::string* PGroup::release_primary_entry_key() {
  clear_has_primary_entry_key();
  if (primary_entry_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = primary_entry_key_;
    primary_entry_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PGroup::set_allocated_primary_entry_key(::std::string* primary_entry_key) {
  if (primary_entry_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete primary_entry_key_;
  }
  if (primary_entry_key) {
    set_has_primary_entry_key();
    primary_entry_key_ = primary_entry_key;
  } else {
    clear_has_primary_entry_key();
    primary_entry_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PGroup.primary_entry_key)
}

// repeated string keys = 3;
inline int PGroup::keys_size() const {
  return keys_.size();
}
inline void PGroup::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& PGroup::keys(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PGroup.keys)
  return keys_.Get(index);
}
inline ::std::string* PGroup::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PGroup.keys)
  return keys_.Mutable(index);
}
inline void PGroup::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:comphealth.PGroup.keys)
  keys_.Mutable(index)->assign(value);
}
inline void PGroup::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PGroup.keys)
}
inline void PGroup::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PGroup.keys)
}
inline ::std::string* PGroup::add_keys() {
  return keys_.Add();
}
inline void PGroup::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:comphealth.PGroup.keys)
}
inline void PGroup::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:comphealth.PGroup.keys)
}
inline void PGroup::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:comphealth.PGroup.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PGroup::keys() const {
  // @@protoc_insertion_point(field_list:comphealth.PGroup.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PGroup::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PGroup.keys)
  return &keys_;
}

// optional string s = 4;
inline bool PGroup::has_s() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PGroup::set_has_s() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PGroup::clear_has_s() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PGroup::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& PGroup::s() const {
  // @@protoc_insertion_point(field_get:comphealth.PGroup.s)
  return *s_;
}
inline void PGroup::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PGroup.s)
}
inline void PGroup::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PGroup.s)
}
inline void PGroup::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PGroup.s)
}
inline ::std::string* PGroup::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PGroup.s)
  return s_;
}
inline ::std::string* PGroup::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PGroup::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PGroup.s)
}

// optional int32 count = 5;
inline bool PGroup::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PGroup::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PGroup::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PGroup::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 PGroup::count() const {
  // @@protoc_insertion_point(field_get:comphealth.PGroup.count)
  return count_;
}
inline void PGroup::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PGroup.count)
}

// -------------------------------------------------------------------

// PEntry

// required string key = 1;
inline bool PEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PEntry::key() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.key)
  return *key_;
}
inline void PEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.key)
}
inline void PEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.key)
}
inline void PEntry::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.key)
}
inline ::std::string* PEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.key)
  return key_;
}
inline ::std::string* PEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.key)
}

// optional string dataset = 2;
inline bool PEntry::has_dataset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PEntry::set_has_dataset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PEntry::clear_has_dataset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PEntry::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& PEntry::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.dataset)
  return *dataset_;
}
inline void PEntry::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.dataset)
}
inline void PEntry::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.dataset)
}
inline void PEntry::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.dataset)
}
inline ::std::string* PEntry::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.dataset)
  return dataset_;
}
inline ::std::string* PEntry::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.dataset)
}

// required .comphealth.ENTRYTYPE etype = 3;
inline bool PEntry::has_etype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PEntry::set_has_etype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PEntry::clear_has_etype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PEntry::clear_etype() {
  etype_ = 1;
  clear_has_etype();
}
inline ::comphealth::ENTRYTYPE PEntry::etype() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.etype)
  return static_cast< ::comphealth::ENTRYTYPE >(etype_);
}
inline void PEntry::set_etype(::comphealth::ENTRYTYPE value) {
  assert(::comphealth::ENTRYTYPE_IsValid(value));
  set_has_etype();
  etype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PEntry.etype)
}

// required string dx = 4;
inline bool PEntry::has_dx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PEntry::set_has_dx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PEntry::clear_has_dx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PEntry::clear_dx() {
  if (dx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_->clear();
  }
  clear_has_dx();
}
inline const ::std::string& PEntry::dx() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.dx)
  return *dx_;
}
inline void PEntry::set_dx(const ::std::string& value) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.dx)
}
inline void PEntry::set_dx(const char* value) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.dx)
}
inline void PEntry::set_dx(const char* value, size_t size) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.dx)
}
inline ::std::string* PEntry::mutable_dx() {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.dx)
  return dx_;
}
inline ::std::string* PEntry::release_dx() {
  clear_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dx_;
    dx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_dx(::std::string* dx) {
  if (dx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dx_;
  }
  if (dx) {
    set_has_dx();
    dx_ = dx;
  } else {
    clear_has_dx();
    dx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.dx)
}

// required string initial = 5;
inline bool PEntry::has_initial() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PEntry::set_has_initial() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PEntry::clear_has_initial() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PEntry::clear_initial() {
  if (initial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_->clear();
  }
  clear_has_initial();
}
inline const ::std::string& PEntry::initial() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.initial)
  return *initial_;
}
inline void PEntry::set_initial(const ::std::string& value) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.initial)
}
inline void PEntry::set_initial(const char* value) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.initial)
}
inline void PEntry::set_initial(const char* value, size_t size) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.initial)
}
inline ::std::string* PEntry::mutable_initial() {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.initial)
  return initial_;
}
inline ::std::string* PEntry::release_initial() {
  clear_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = initial_;
    initial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_initial(::std::string* initial) {
  if (initial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete initial_;
  }
  if (initial) {
    set_has_initial();
    initial_ = initial;
  } else {
    clear_has_initial();
    initial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.initial)
}

// required string sub = 6;
inline bool PEntry::has_sub() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PEntry::set_has_sub() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PEntry::clear_has_sub() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PEntry::clear_sub() {
  if (sub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_->clear();
  }
  clear_has_sub();
}
inline const ::std::string& PEntry::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.sub)
  return *sub_;
}
inline void PEntry::set_sub(const ::std::string& value) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.sub)
}
inline void PEntry::set_sub(const char* value) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.sub)
}
inline void PEntry::set_sub(const char* value, size_t size) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.sub)
}
inline ::std::string* PEntry::mutable_sub() {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.sub)
  return sub_;
}
inline ::std::string* PEntry::release_sub() {
  clear_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sub_;
    sub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_sub(::std::string* sub) {
  if (sub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sub_;
  }
  if (sub) {
    set_has_sub();
    sub_ = sub;
  } else {
    clear_has_sub();
    sub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.sub)
}

// required .comphealth.IntHist deltah = 7;
inline bool PEntry::has_deltah() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PEntry::set_has_deltah() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PEntry::clear_has_deltah() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PEntry::clear_deltah() {
  if (deltah_ != NULL) deltah_->::comphealth::IntHist::Clear();
  clear_has_deltah();
}
inline const ::comphealth::IntHist& PEntry::deltah() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.deltah)
  return deltah_ != NULL ? *deltah_ : *default_instance_->deltah_;
}
inline ::comphealth::IntHist* PEntry::mutable_deltah() {
  set_has_deltah();
  if (deltah_ == NULL) deltah_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.deltah)
  return deltah_;
}
inline ::comphealth::IntHist* PEntry::release_deltah() {
  clear_has_deltah();
  ::comphealth::IntHist* temp = deltah_;
  deltah_ = NULL;
  return temp;
}
inline void PEntry::set_allocated_deltah(::comphealth::IntHist* deltah) {
  delete deltah_;
  deltah_ = deltah;
  if (deltah) {
    set_has_deltah();
  } else {
    clear_has_deltah();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.deltah)
}

// required .comphealth.AGG stats = 8;
inline bool PEntry::has_stats() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PEntry::set_has_stats() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PEntry::clear_has_stats() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PEntry::clear_stats() {
  if (stats_ != NULL) stats_->::comphealth::AGG::Clear();
  clear_has_stats();
}
inline const ::comphealth::AGG& PEntry::stats() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.stats)
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::comphealth::AGG* PEntry::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.stats)
  return stats_;
}
inline ::comphealth::AGG* PEntry::release_stats() {
  clear_has_stats();
  ::comphealth::AGG* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void PEntry::set_allocated_stats(::comphealth::AGG* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.stats)
}

// repeated .comphealth.ISubset delta_subset = 9;
inline int PEntry::delta_subset_size() const {
  return delta_subset_.size();
}
inline void PEntry::clear_delta_subset() {
  delta_subset_.Clear();
}
inline const ::comphealth::ISubset& PEntry::delta_subset(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.delta_subset)
  return delta_subset_.Get(index);
}
inline ::comphealth::ISubset* PEntry::mutable_delta_subset(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.delta_subset)
  return delta_subset_.Mutable(index);
}
inline ::comphealth::ISubset* PEntry::add_delta_subset() {
  // @@protoc_insertion_point(field_add:comphealth.PEntry.delta_subset)
  return delta_subset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >&
PEntry::delta_subset() const {
  // @@protoc_insertion_point(field_list:comphealth.PEntry.delta_subset)
  return delta_subset_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >*
PEntry::mutable_delta_subset() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PEntry.delta_subset)
  return &delta_subset_;
}

// repeated .comphealth.SSubset age_subset = 10;
inline int PEntry::age_subset_size() const {
  return age_subset_.size();
}
inline void PEntry::clear_age_subset() {
  age_subset_.Clear();
}
inline const ::comphealth::SSubset& PEntry::age_subset(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.age_subset)
  return age_subset_.Get(index);
}
inline ::comphealth::SSubset* PEntry::mutable_age_subset(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.age_subset)
  return age_subset_.Mutable(index);
}
inline ::comphealth::SSubset* PEntry::add_age_subset() {
  // @@protoc_insertion_point(field_add:comphealth.PEntry.age_subset)
  return age_subset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SSubset >&
PEntry::age_subset() const {
  // @@protoc_insertion_point(field_list:comphealth.PEntry.age_subset)
  return age_subset_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::SSubset >*
PEntry::mutable_age_subset() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PEntry.age_subset)
  return &age_subset_;
}

// repeated .comphealth.ISubset year_subset = 11;
inline int PEntry::year_subset_size() const {
  return year_subset_.size();
}
inline void PEntry::clear_year_subset() {
  year_subset_.Clear();
}
inline const ::comphealth::ISubset& PEntry::year_subset(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.year_subset)
  return year_subset_.Get(index);
}
inline ::comphealth::ISubset* PEntry::mutable_year_subset(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.year_subset)
  return year_subset_.Mutable(index);
}
inline ::comphealth::ISubset* PEntry::add_year_subset() {
  // @@protoc_insertion_point(field_add:comphealth.PEntry.year_subset)
  return year_subset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >&
PEntry::year_subset() const {
  // @@protoc_insertion_point(field_list:comphealth.PEntry.year_subset)
  return year_subset_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::ISubset >*
PEntry::mutable_year_subset() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PEntry.year_subset)
  return &year_subset_;
}

// repeated .comphealth.RSEntry state_subset = 12;
inline int PEntry::state_subset_size() const {
  return state_subset_.size();
}
inline void PEntry::clear_state_subset() {
  state_subset_.Clear();
}
inline const ::comphealth::RSEntry& PEntry::state_subset(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.state_subset)
  return state_subset_.Get(index);
}
inline ::comphealth::RSEntry* PEntry::mutable_state_subset(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.state_subset)
  return state_subset_.Mutable(index);
}
inline ::comphealth::RSEntry* PEntry::add_state_subset() {
  // @@protoc_insertion_point(field_add:comphealth.PEntry.state_subset)
  return state_subset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::RSEntry >&
PEntry::state_subset() const {
  // @@protoc_insertion_point(field_list:comphealth.PEntry.state_subset)
  return state_subset_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::RSEntry >*
PEntry::mutable_state_subset() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PEntry.state_subset)
  return &state_subset_;
}

// optional string dataset_s = 16;
inline bool PEntry::has_dataset_s() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PEntry::set_has_dataset_s() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PEntry::clear_has_dataset_s() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PEntry::clear_dataset_s() {
  if (dataset_s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_s_->clear();
  }
  clear_has_dataset_s();
}
inline const ::std::string& PEntry::dataset_s() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.dataset_s)
  return *dataset_s_;
}
inline void PEntry::set_dataset_s(const ::std::string& value) {
  set_has_dataset_s();
  if (dataset_s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_s_ = new ::std::string;
  }
  dataset_s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PEntry.dataset_s)
}
inline void PEntry::set_dataset_s(const char* value) {
  set_has_dataset_s();
  if (dataset_s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_s_ = new ::std::string;
  }
  dataset_s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PEntry.dataset_s)
}
inline void PEntry::set_dataset_s(const char* value, size_t size) {
  set_has_dataset_s();
  if (dataset_s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_s_ = new ::std::string;
  }
  dataset_s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PEntry.dataset_s)
}
inline ::std::string* PEntry::mutable_dataset_s() {
  set_has_dataset_s();
  if (dataset_s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.dataset_s)
  return dataset_s_;
}
inline ::std::string* PEntry::release_dataset_s() {
  clear_has_dataset_s();
  if (dataset_s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_s_;
    dataset_s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PEntry::set_allocated_dataset_s(::std::string* dataset_s) {
  if (dataset_s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_s_;
  }
  if (dataset_s) {
    set_has_dataset_s();
    dataset_s_ = dataset_s;
  } else {
    clear_has_dataset_s();
    dataset_s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PEntry.dataset_s)
}

// repeated .comphealth.Exclusion provenance = 17;
inline int PEntry::provenance_size() const {
  return provenance_.size();
}
inline void PEntry::clear_provenance() {
  provenance_.Clear();
}
inline const ::comphealth::Exclusion& PEntry::provenance(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.provenance)
  return provenance_.Get(index);
}
inline ::comphealth::Exclusion* PEntry::mutable_provenance(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PEntry.provenance)
  return provenance_.Mutable(index);
}
inline ::comphealth::Exclusion* PEntry::add_provenance() {
  // @@protoc_insertion_point(field_add:comphealth.PEntry.provenance)
  return provenance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >&
PEntry::provenance() const {
  // @@protoc_insertion_point(field_list:comphealth.PEntry.provenance)
  return provenance_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusion >*
PEntry::mutable_provenance() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PEntry.provenance)
  return &provenance_;
}

// optional bool pediatric = 18 [default = false];
inline bool PEntry::has_pediatric() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PEntry::set_has_pediatric() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PEntry::clear_has_pediatric() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PEntry::clear_pediatric() {
  pediatric_ = false;
  clear_has_pediatric();
}
inline bool PEntry::pediatric() const {
  // @@protoc_insertion_point(field_get:comphealth.PEntry.pediatric)
  return pediatric_;
}
inline void PEntry::set_pediatric(bool value) {
  set_has_pediatric();
  pediatric_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PEntry.pediatric)
}

// -------------------------------------------------------------------

// Exclusion

// required int32 k = 1;
inline bool Exclusion::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exclusion::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exclusion::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exclusion::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline ::google::protobuf::int32 Exclusion::k() const {
  // @@protoc_insertion_point(field_get:comphealth.Exclusion.k)
  return k_;
}
inline void Exclusion::set_k(::google::protobuf::int32 value) {
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Exclusion.k)
}

// optional string s = 3;
inline bool Exclusion::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exclusion::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exclusion::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exclusion::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& Exclusion::s() const {
  // @@protoc_insertion_point(field_get:comphealth.Exclusion.s)
  return *s_;
}
inline void Exclusion::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Exclusion.s)
}
inline void Exclusion::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Exclusion.s)
}
inline void Exclusion::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Exclusion.s)
}
inline ::std::string* Exclusion::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Exclusion.s)
  return s_;
}
inline ::std::string* Exclusion::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Exclusion::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Exclusion.s)
}

// -------------------------------------------------------------------

// ISubset

// required int32 k = 1;
inline bool ISubset::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ISubset::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ISubset::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ISubset::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline ::google::protobuf::int32 ISubset::k() const {
  // @@protoc_insertion_point(field_get:comphealth.ISubset.k)
  return k_;
}
inline void ISubset::set_k(::google::protobuf::int32 value) {
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.ISubset.k)
}

// required .comphealth.AGG subset = 2;
inline bool ISubset::has_subset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ISubset::set_has_subset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ISubset::clear_has_subset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ISubset::clear_subset() {
  if (subset_ != NULL) subset_->::comphealth::AGG::Clear();
  clear_has_subset();
}
inline const ::comphealth::AGG& ISubset::subset() const {
  // @@protoc_insertion_point(field_get:comphealth.ISubset.subset)
  return subset_ != NULL ? *subset_ : *default_instance_->subset_;
}
inline ::comphealth::AGG* ISubset::mutable_subset() {
  set_has_subset();
  if (subset_ == NULL) subset_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.ISubset.subset)
  return subset_;
}
inline ::comphealth::AGG* ISubset::release_subset() {
  clear_has_subset();
  ::comphealth::AGG* temp = subset_;
  subset_ = NULL;
  return temp;
}
inline void ISubset::set_allocated_subset(::comphealth::AGG* subset) {
  delete subset_;
  subset_ = subset;
  if (subset) {
    set_has_subset();
  } else {
    clear_has_subset();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.ISubset.subset)
}

// optional string s = 3;
inline bool ISubset::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ISubset::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ISubset::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ISubset::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& ISubset::s() const {
  // @@protoc_insertion_point(field_get:comphealth.ISubset.s)
  return *s_;
}
inline void ISubset::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.ISubset.s)
}
inline void ISubset::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.ISubset.s)
}
inline void ISubset::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.ISubset.s)
}
inline ::std::string* ISubset::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.ISubset.s)
  return s_;
}
inline ::std::string* ISubset::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ISubset::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.ISubset.s)
}

// -------------------------------------------------------------------

// SSubset

// required string k = 1;
inline bool SSubset::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSubset::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSubset::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSubset::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& SSubset::k() const {
  // @@protoc_insertion_point(field_get:comphealth.SSubset.k)
  return *k_;
}
inline void SSubset::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.SSubset.k)
}
inline void SSubset::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.SSubset.k)
}
inline void SSubset::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.SSubset.k)
}
inline ::std::string* SSubset::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.SSubset.k)
  return k_;
}
inline ::std::string* SSubset::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SSubset::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.SSubset.k)
}

// required .comphealth.AGG subset = 2;
inline bool SSubset::has_subset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSubset::set_has_subset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSubset::clear_has_subset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSubset::clear_subset() {
  if (subset_ != NULL) subset_->::comphealth::AGG::Clear();
  clear_has_subset();
}
inline const ::comphealth::AGG& SSubset::subset() const {
  // @@protoc_insertion_point(field_get:comphealth.SSubset.subset)
  return subset_ != NULL ? *subset_ : *default_instance_->subset_;
}
inline ::comphealth::AGG* SSubset::mutable_subset() {
  set_has_subset();
  if (subset_ == NULL) subset_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.SSubset.subset)
  return subset_;
}
inline ::comphealth::AGG* SSubset::release_subset() {
  clear_has_subset();
  ::comphealth::AGG* temp = subset_;
  subset_ = NULL;
  return temp;
}
inline void SSubset::set_allocated_subset(::comphealth::AGG* subset) {
  delete subset_;
  subset_ = subset;
  if (subset) {
    set_has_subset();
  } else {
    clear_has_subset();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.SSubset.subset)
}

// optional string s = 3;
inline bool SSubset::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSubset::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSubset::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSubset::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& SSubset::s() const {
  // @@protoc_insertion_point(field_get:comphealth.SSubset.s)
  return *s_;
}
inline void SSubset::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.SSubset.s)
}
inline void SSubset::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.SSubset.s)
}
inline void SSubset::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.SSubset.s)
}
inline ::std::string* SSubset::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.SSubset.s)
  return s_;
}
inline ::std::string* SSubset::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SSubset::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.SSubset.s)
}

// -------------------------------------------------------------------

// RSEntry

// required string k = 1;
inline bool RSEntry::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RSEntry::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RSEntry::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RSEntry::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& RSEntry::k() const {
  // @@protoc_insertion_point(field_get:comphealth.RSEntry.k)
  return *k_;
}
inline void RSEntry::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.RSEntry.k)
}
inline void RSEntry::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.RSEntry.k)
}
inline void RSEntry::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.RSEntry.k)
}
inline ::std::string* RSEntry::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.RSEntry.k)
  return k_;
}
inline ::std::string* RSEntry::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSEntry::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.RSEntry.k)
}

// required .comphealth.PEntry subset = 2;
inline bool RSEntry::has_subset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RSEntry::set_has_subset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RSEntry::clear_has_subset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RSEntry::clear_subset() {
  if (subset_ != NULL) subset_->::comphealth::PEntry::Clear();
  clear_has_subset();
}
inline const ::comphealth::PEntry& RSEntry::subset() const {
  // @@protoc_insertion_point(field_get:comphealth.RSEntry.subset)
  return subset_ != NULL ? *subset_ : *default_instance_->subset_;
}
inline ::comphealth::PEntry* RSEntry::mutable_subset() {
  set_has_subset();
  if (subset_ == NULL) subset_ = new ::comphealth::PEntry;
  // @@protoc_insertion_point(field_mutable:comphealth.RSEntry.subset)
  return subset_;
}
inline ::comphealth::PEntry* RSEntry::release_subset() {
  clear_has_subset();
  ::comphealth::PEntry* temp = subset_;
  subset_ = NULL;
  return temp;
}
inline void RSEntry::set_allocated_subset(::comphealth::PEntry* subset) {
  delete subset_;
  subset_ = subset;
  if (subset) {
    set_has_subset();
  } else {
    clear_has_subset();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.RSEntry.subset)
}

// optional string s = 3;
inline bool RSEntry::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RSEntry::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RSEntry::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RSEntry::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& RSEntry::s() const {
  // @@protoc_insertion_point(field_get:comphealth.RSEntry.s)
  return *s_;
}
inline void RSEntry::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.RSEntry.s)
}
inline void RSEntry::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.RSEntry.s)
}
inline void RSEntry::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.RSEntry.s)
}
inline ::std::string* RSEntry::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.RSEntry.s)
  return s_;
}
inline ::std::string* RSEntry::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSEntry::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.RSEntry.s)
}

// -------------------------------------------------------------------

// PLVisits

// repeated .comphealth.PLVisit plvisits = 1;
inline int PLVisits::plvisits_size() const {
  return plvisits_.size();
}
inline void PLVisits::clear_plvisits() {
  plvisits_.Clear();
}
inline const ::comphealth::PLVisit& PLVisits::plvisits(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisits.plvisits)
  return plvisits_.Get(index);
}
inline ::comphealth::PLVisit* PLVisits::mutable_plvisits(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PLVisits.plvisits)
  return plvisits_.Mutable(index);
}
inline ::comphealth::PLVisit* PLVisits::add_plvisits() {
  // @@protoc_insertion_point(field_add:comphealth.PLVisits.plvisits)
  return plvisits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PLVisit >&
PLVisits::plvisits() const {
  // @@protoc_insertion_point(field_list:comphealth.PLVisits.plvisits)
  return plvisits_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::PLVisit >*
PLVisits::mutable_plvisits() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PLVisits.plvisits)
  return &plvisits_;
}

// -------------------------------------------------------------------

// PLVisit

// required string dx = 1;
inline bool PLVisit::has_dx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PLVisit::set_has_dx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PLVisit::clear_has_dx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PLVisit::clear_dx() {
  if (dx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_->clear();
  }
  clear_has_dx();
}
inline const ::std::string& PLVisit::dx() const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisit.dx)
  return *dx_;
}
inline void PLVisit::set_dx(const ::std::string& value) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PLVisit.dx)
}
inline void PLVisit::set_dx(const char* value) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PLVisit.dx)
}
inline void PLVisit::set_dx(const char* value, size_t size) {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  dx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PLVisit.dx)
}
inline ::std::string* PLVisit::mutable_dx() {
  set_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PLVisit.dx)
  return dx_;
}
inline ::std::string* PLVisit::release_dx() {
  clear_has_dx();
  if (dx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dx_;
    dx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PLVisit::set_allocated_dx(::std::string* dx) {
  if (dx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dx_;
  }
  if (dx) {
    set_has_dx();
    dx_ = dx;
  } else {
    clear_has_dx();
    dx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PLVisit.dx)
}

// required string initial = 2;
inline bool PLVisit::has_initial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PLVisit::set_has_initial() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PLVisit::clear_has_initial() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PLVisit::clear_initial() {
  if (initial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_->clear();
  }
  clear_has_initial();
}
inline const ::std::string& PLVisit::initial() const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisit.initial)
  return *initial_;
}
inline void PLVisit::set_initial(const ::std::string& value) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PLVisit.initial)
}
inline void PLVisit::set_initial(const char* value) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PLVisit.initial)
}
inline void PLVisit::set_initial(const char* value, size_t size) {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  initial_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PLVisit.initial)
}
inline ::std::string* PLVisit::mutable_initial() {
  set_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    initial_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PLVisit.initial)
  return initial_;
}
inline ::std::string* PLVisit::release_initial() {
  clear_has_initial();
  if (initial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = initial_;
    initial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PLVisit::set_allocated_initial(::std::string* initial) {
  if (initial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete initial_;
  }
  if (initial) {
    set_has_initial();
    initial_ = initial;
  } else {
    clear_has_initial();
    initial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PLVisit.initial)
}

// required string sub = 3;
inline bool PLVisit::has_sub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PLVisit::set_has_sub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PLVisit::clear_has_sub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PLVisit::clear_sub() {
  if (sub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_->clear();
  }
  clear_has_sub();
}
inline const ::std::string& PLVisit::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisit.sub)
  return *sub_;
}
inline void PLVisit::set_sub(const ::std::string& value) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PLVisit.sub)
}
inline void PLVisit::set_sub(const char* value) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PLVisit.sub)
}
inline void PLVisit::set_sub(const char* value, size_t size) {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  sub_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PLVisit.sub)
}
inline ::std::string* PLVisit::mutable_sub() {
  set_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sub_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PLVisit.sub)
  return sub_;
}
inline ::std::string* PLVisit::release_sub() {
  clear_has_sub();
  if (sub_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sub_;
    sub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PLVisit::set_allocated_sub(::std::string* sub) {
  if (sub_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sub_;
  }
  if (sub) {
    set_has_sub();
    sub_ = sub;
  } else {
    clear_has_sub();
    sub_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PLVisit.sub)
}

// required int32 delta = 4;
inline bool PLVisit::has_delta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PLVisit::set_has_delta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PLVisit::clear_has_delta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PLVisit::clear_delta() {
  delta_ = 0;
  clear_has_delta();
}
inline ::google::protobuf::int32 PLVisit::delta() const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisit.delta)
  return delta_;
}
inline void PLVisit::set_delta(::google::protobuf::int32 value) {
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PLVisit.delta)
}

// required .comphealth.Visit v = 5;
inline bool PLVisit::has_v() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PLVisit::set_has_v() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PLVisit::clear_has_v() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PLVisit::clear_v() {
  if (v_ != NULL) v_->::comphealth::Visit::Clear();
  clear_has_v();
}
inline const ::comphealth::Visit& PLVisit::v() const {
  // @@protoc_insertion_point(field_get:comphealth.PLVisit.v)
  return v_ != NULL ? *v_ : *default_instance_->v_;
}
inline ::comphealth::Visit* PLVisit::mutable_v() {
  set_has_v();
  if (v_ == NULL) v_ = new ::comphealth::Visit;
  // @@protoc_insertion_point(field_mutable:comphealth.PLVisit.v)
  return v_;
}
inline ::comphealth::Visit* PLVisit::release_v() {
  clear_has_v();
  ::comphealth::Visit* temp = v_;
  v_ = NULL;
  return temp;
}
inline void PLVisit::set_allocated_v(::comphealth::Visit* v) {
  delete v_;
  v_ = v;
  if (v) {
    set_has_v();
  } else {
    clear_has_v();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PLVisit.v)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::comphealth::ENTRYTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::ENTRYTYPE>() {
  return ::comphealth::ENTRYTYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pn1_2eproto__INCLUDED
