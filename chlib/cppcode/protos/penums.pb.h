// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: penums.proto

#ifndef PROTOBUF_penums_2eproto__INCLUDED
#define PROTOBUF_penums_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_penums_2eproto();
void protobuf_AssignDesc_penums_2eproto();
void protobuf_ShutdownFile_penums_2eproto();


enum ETYPE {
  IP = 0,
  ED = 1,
  AS = 2,
  OUT = 3,
  H = 4,
  O = 5,
  ALL = 6
};
bool ETYPE_IsValid(int value);
const ETYPE ETYPE_MIN = IP;
const ETYPE ETYPE_MAX = ALL;
const int ETYPE_ARRAYSIZE = ETYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETYPE_descriptor();
inline const ::std::string& ETYPE_Name(ETYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETYPE_descriptor(), value);
}
inline bool ETYPE_Parse(
    const ::std::string& name, ETYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETYPE>(
    ETYPE_descriptor(), name, value);
}
enum SEX {
  MALE = 10,
  FEMALE = 11,
  SEX_UNKNOWN = 12
};
bool SEX_IsValid(int value);
const SEX SEX_MIN = MALE;
const SEX SEX_MAX = SEX_UNKNOWN;
const int SEX_ARRAYSIZE = SEX_MAX + 1;

const ::google::protobuf::EnumDescriptor* SEX_descriptor();
inline const ::std::string& SEX_Name(SEX value) {
  return ::google::protobuf::internal::NameOfEnum(
    SEX_descriptor(), value);
}
inline bool SEX_Parse(
    const ::std::string& name, SEX* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SEX>(
    SEX_descriptor(), name, value);
}
enum DEATH {
  ALIVE = 30,
  DEAD = 31,
  DEATH_UNKNOWN = 32
};
bool DEATH_IsValid(int value);
const DEATH DEATH_MIN = ALIVE;
const DEATH DEATH_MAX = DEATH_UNKNOWN;
const int DEATH_ARRAYSIZE = DEATH_MAX + 1;

const ::google::protobuf::EnumDescriptor* DEATH_descriptor();
inline const ::std::string& DEATH_Name(DEATH value) {
  return ::google::protobuf::internal::NameOfEnum(
    DEATH_descriptor(), value);
}
inline bool DEATH_Parse(
    const ::std::string& name, DEATH* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DEATH>(
    DEATH_descriptor(), name, value);
}
enum PAYER {
  MEDICARE = 41,
  MEDICAID = 42,
  PRIVATE = 43,
  SELF = 44,
  OTHER = 45,
  P_UNKNOWN = 46,
  FREE = 47
};
bool PAYER_IsValid(int value);
const PAYER PAYER_MIN = MEDICARE;
const PAYER PAYER_MAX = FREE;
const int PAYER_ARRAYSIZE = PAYER_MAX + 1;

const ::google::protobuf::EnumDescriptor* PAYER_descriptor();
inline const ::std::string& PAYER_Name(PAYER value) {
  return ::google::protobuf::internal::NameOfEnum(
    PAYER_descriptor(), value);
}
inline bool PAYER_Parse(
    const ::std::string& name, PAYER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PAYER>(
    PAYER_descriptor(), name, value);
}
enum RACE {
  WHITE = 51,
  BLACK = 52,
  HISPANIC = 53,
  ASIAN = 54,
  NATIVE = 55,
  R_OTHER = 56,
  R_UNKNOWN = 57
};
bool RACE_IsValid(int value);
const RACE RACE_MIN = WHITE;
const RACE RACE_MAX = R_UNKNOWN;
const int RACE_ARRAYSIZE = RACE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RACE_descriptor();
inline const ::std::string& RACE_Name(RACE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RACE_descriptor(), value);
}
inline bool RACE_Parse(
    const ::std::string& name, RACE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RACE>(
    RACE_descriptor(), name, value);
}
enum SOURCE {
  S_ROUTINE = 61,
  S_HOSPITAL = 62,
  S_SNF = 63,
  S_HOME = 64,
  S_OTHER = 65,
  S_ED = 66,
  S_UNKNOWN = 67,
  S_COURT = 68,
  S_TEXAS_PSYCH = 600,
  S_TEXAS_CRITICAL = 601,
  S_TEXAS_INTERNAL = 602
};
bool SOURCE_IsValid(int value);
const SOURCE SOURCE_MIN = S_ROUTINE;
const SOURCE SOURCE_MAX = S_TEXAS_INTERNAL;
const int SOURCE_ARRAYSIZE = SOURCE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SOURCE_descriptor();
inline const ::std::string& SOURCE_Name(SOURCE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SOURCE_descriptor(), value);
}
inline bool SOURCE_Parse(
    const ::std::string& name, SOURCE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SOURCE>(
    SOURCE_descriptor(), name, value);
}
enum DISPOSITION {
  D_ROUTINE = 71,
  D_HOSPITAL = 72,
  D_SNF = 73,
  D_ICF = 701,
  D_HOME = 74,
  D_DEATH = 75,
  D_OTHER = 76,
  D_UNKNOWN = 77,
  D_AMA = 78,
  D_UNKNOWNALIVE = 79,
  D_COURT = 70
};
bool DISPOSITION_IsValid(int value);
const DISPOSITION DISPOSITION_MIN = D_COURT;
const DISPOSITION DISPOSITION_MAX = D_ICF;
const int DISPOSITION_ARRAYSIZE = DISPOSITION_MAX + 1;

const ::google::protobuf::EnumDescriptor* DISPOSITION_descriptor();
inline const ::std::string& DISPOSITION_Name(DISPOSITION value) {
  return ::google::protobuf::internal::NameOfEnum(
    DISPOSITION_descriptor(), value);
}
inline bool DISPOSITION_Parse(
    const ::std::string& name, DISPOSITION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DISPOSITION>(
    DISPOSITION_descriptor(), name, value);
}
enum DNR {
  DNR_NO = 80,
  DNR_YES = 81,
  DNR_UNKNOWN = 82,
  DNR_UNAVAILABLE = 83
};
bool DNR_IsValid(int value);
const DNR DNR_MIN = DNR_NO;
const DNR DNR_MAX = DNR_UNAVAILABLE;
const int DNR_ARRAYSIZE = DNR_MAX + 1;

const ::google::protobuf::EnumDescriptor* DNR_descriptor();
inline const ::std::string& DNR_Name(DNR value) {
  return ::google::protobuf::internal::NameOfEnum(
    DNR_descriptor(), value);
}
inline bool DNR_Parse(
    const ::std::string& name, DNR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DNR>(
    DNR_descriptor(), name, value);
}
enum CTYPE {
  ICD = 90,
  CPT = 91
};
bool CTYPE_IsValid(int value);
const CTYPE CTYPE_MIN = ICD;
const CTYPE CTYPE_MAX = CPT;
const int CTYPE_ARRAYSIZE = CTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CTYPE_descriptor();
inline const ::std::string& CTYPE_Name(CTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CTYPE_descriptor(), value);
}
inline bool CTYPE_Parse(
    const ::std::string& name, CTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CTYPE>(
    CTYPE_descriptor(), name, value);
}
enum PZIP {
  Z_FIRST = 101,
  Z_SECOND = 102,
  Z_THIRD = 103,
  Z_FOURTH = 104,
  Z_UNKNOWN = 105
};
bool PZIP_IsValid(int value);
const PZIP PZIP_MIN = Z_FIRST;
const PZIP PZIP_MAX = Z_UNKNOWN;
const int PZIP_ARRAYSIZE = PZIP_MAX + 1;

const ::google::protobuf::EnumDescriptor* PZIP_descriptor();
inline const ::std::string& PZIP_Name(PZIP value) {
  return ::google::protobuf::internal::NameOfEnum(
    PZIP_descriptor(), value);
}
inline bool PZIP_Parse(
    const ::std::string& name, PZIP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PZIP>(
    PZIP_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::comphealth::ETYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::ETYPE>() {
  return ::comphealth::ETYPE_descriptor();
}
template <> struct is_proto_enum< ::comphealth::SEX> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::SEX>() {
  return ::comphealth::SEX_descriptor();
}
template <> struct is_proto_enum< ::comphealth::DEATH> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::DEATH>() {
  return ::comphealth::DEATH_descriptor();
}
template <> struct is_proto_enum< ::comphealth::PAYER> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::PAYER>() {
  return ::comphealth::PAYER_descriptor();
}
template <> struct is_proto_enum< ::comphealth::RACE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::RACE>() {
  return ::comphealth::RACE_descriptor();
}
template <> struct is_proto_enum< ::comphealth::SOURCE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::SOURCE>() {
  return ::comphealth::SOURCE_descriptor();
}
template <> struct is_proto_enum< ::comphealth::DISPOSITION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::DISPOSITION>() {
  return ::comphealth::DISPOSITION_descriptor();
}
template <> struct is_proto_enum< ::comphealth::DNR> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::DNR>() {
  return ::comphealth::DNR_descriptor();
}
template <> struct is_proto_enum< ::comphealth::CTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::CTYPE>() {
  return ::comphealth::CTYPE_descriptor();
}
template <> struct is_proto_enum< ::comphealth::PZIP> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comphealth::PZIP>() {
  return ::comphealth::PZIP_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_penums_2eproto__INCLUDED
