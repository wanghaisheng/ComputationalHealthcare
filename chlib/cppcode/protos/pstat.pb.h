// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pstat.proto

#ifndef PROTOBUF_pstat_2eproto__INCLUDED
#define PROTOBUF_pstat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "penums.pb.h"
#include "pvisit.pb.h"
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pstat_2eproto();
void protobuf_AssignDesc_pstat_2eproto();
void protobuf_ShutdownFile_pstat_2eproto();

class PAGG;
class PSubsets;
class VisitDeltaHist;
class AGG;
class Policy;
class IntHist;
class KVII;
class DXI;
class DispositionHist;
class EtypeHist;
class EtypeCountHist;
class SourceHist;
class PayerHist;
class RaceHist;
class DeathHist;
class SexHist;
class DNRHist;
class PZipHist;

// ===================================================================

class PAGG : public ::google::protobuf::Message {
 public:
  PAGG();
  virtual ~PAGG();

  PAGG(const PAGG& from);

  inline PAGG& operator=(const PAGG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PAGG& default_instance();

  void Swap(PAGG* other);

  // implements Message ----------------------------------------------

  PAGG* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PAGG& from);
  void MergeFrom(const PAGG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string dataset = 2;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 2;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // required bool linked = 3;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 3;
  inline bool linked() const;
  inline void set_linked(bool value);

  // required bool unlinked = 4;
  inline bool has_unlinked() const;
  inline void clear_unlinked();
  static const int kUnlinkedFieldNumber = 4;
  inline bool unlinked() const;
  inline void set_unlinked(bool value);

  // required int32 patient_count = 6;
  inline bool has_patient_count() const;
  inline void clear_patient_count();
  static const int kPatientCountFieldNumber = 6;
  inline ::google::protobuf::int32 patient_count() const;
  inline void set_patient_count(::google::protobuf::int32 value);

  // required int32 visit_count = 7;
  inline bool has_visit_count() const;
  inline void clear_visit_count();
  static const int kVisitCountFieldNumber = 7;
  inline ::google::protobuf::int32 visit_count() const;
  inline void set_visit_count(::google::protobuf::int32 value);

  // required int32 linked_count = 8;
  inline bool has_linked_count() const;
  inline void clear_linked_count();
  static const int kLinkedCountFieldNumber = 8;
  inline ::google::protobuf::int32 linked_count() const;
  inline void set_linked_count(::google::protobuf::int32 value);

  // required int32 unlinked_count = 9;
  inline bool has_unlinked_count() const;
  inline void clear_unlinked_count();
  static const int kUnlinkedCountFieldNumber = 9;
  inline ::google::protobuf::int32 unlinked_count() const;
  inline void set_unlinked_count(::google::protobuf::int32 value);

  // repeated .comphealth.PSubsets subsets = 10;
  inline int subsets_size() const;
  inline void clear_subsets();
  static const int kSubsetsFieldNumber = 10;
  inline const ::comphealth::PSubsets& subsets(int index) const;
  inline ::comphealth::PSubsets* mutable_subsets(int index);
  inline ::comphealth::PSubsets* add_subsets();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PSubsets >&
      subsets() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::PSubsets >*
      mutable_subsets();

  // repeated .comphealth.VisitDeltaHist delta_hist = 11;
  inline int delta_hist_size() const;
  inline void clear_delta_hist();
  static const int kDeltaHistFieldNumber = 11;
  inline const ::comphealth::VisitDeltaHist& delta_hist(int index) const;
  inline ::comphealth::VisitDeltaHist* mutable_delta_hist(int index);
  inline ::comphealth::VisitDeltaHist* add_delta_hist();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >&
      delta_hist() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >*
      mutable_delta_hist();

  // repeated .comphealth.VisitDeltaHist delta_error_hist = 13;
  inline int delta_error_hist_size() const;
  inline void clear_delta_error_hist();
  static const int kDeltaErrorHistFieldNumber = 13;
  inline const ::comphealth::VisitDeltaHist& delta_error_hist(int index) const;
  inline ::comphealth::VisitDeltaHist* mutable_delta_error_hist(int index);
  inline ::comphealth::VisitDeltaHist* add_delta_error_hist();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >&
      delta_error_hist() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >*
      mutable_delta_error_hist();

  // repeated .comphealth.EtypeCountHist count_hist = 12;
  inline int count_hist_size() const;
  inline void clear_count_hist();
  static const int kCountHistFieldNumber = 12;
  inline const ::comphealth::EtypeCountHist& count_hist(int index) const;
  inline ::comphealth::EtypeCountHist* mutable_count_hist(int index);
  inline ::comphealth::EtypeCountHist* add_count_hist();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeCountHist >&
      count_hist() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeCountHist >*
      mutable_count_hist();

  // optional int32 edge_count = 14;
  inline bool has_edge_count() const;
  inline void clear_edge_count();
  static const int kEdgeCountFieldNumber = 14;
  inline ::google::protobuf::int32 edge_count() const;
  inline void set_edge_count(::google::protobuf::int32 value);

  // optional int32 negative_delta_count = 15;
  inline bool has_negative_delta_count() const;
  inline void clear_negative_delta_count();
  static const int kNegativeDeltaCountFieldNumber = 15;
  inline ::google::protobuf::int32 negative_delta_count() const;
  inline void set_negative_delta_count(::google::protobuf::int32 value);

  // required .comphealth.Policy policy = 16;
  inline bool has_policy() const;
  inline void clear_policy();
  static const int kPolicyFieldNumber = 16;
  inline const ::comphealth::Policy& policy() const;
  inline ::comphealth::Policy* mutable_policy();
  inline ::comphealth::Policy* release_policy();
  inline void set_allocated_policy(::comphealth::Policy* policy);

  // @@protoc_insertion_point(class_scope:comphealth.PAGG)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_dataset();
  inline void clear_has_dataset();
  inline void set_has_linked();
  inline void clear_has_linked();
  inline void set_has_unlinked();
  inline void clear_has_unlinked();
  inline void set_has_patient_count();
  inline void clear_has_patient_count();
  inline void set_has_visit_count();
  inline void clear_has_visit_count();
  inline void set_has_linked_count();
  inline void clear_has_linked_count();
  inline void set_has_unlinked_count();
  inline void clear_has_unlinked_count();
  inline void set_has_edge_count();
  inline void clear_has_edge_count();
  inline void set_has_negative_delta_count();
  inline void clear_has_negative_delta_count();
  inline void set_has_policy();
  inline void clear_has_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* dataset_;
  bool linked_;
  bool unlinked_;
  ::google::protobuf::int32 patient_count_;
  ::google::protobuf::int32 visit_count_;
  ::google::protobuf::int32 linked_count_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::PSubsets > subsets_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist > delta_hist_;
  ::google::protobuf::int32 unlinked_count_;
  ::google::protobuf::int32 edge_count_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist > delta_error_hist_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeCountHist > count_hist_;
  ::comphealth::Policy* policy_;
  ::google::protobuf::int32 negative_delta_count_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static PAGG* default_instance_;
};
// -------------------------------------------------------------------

class PSubsets : public ::google::protobuf::Message {
 public:
  PSubsets();
  virtual ~PSubsets();

  PSubsets(const PSubsets& from);

  inline PSubsets& operator=(const PSubsets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PSubsets& default_instance();

  void Swap(PSubsets* other);

  // implements Message ----------------------------------------------

  PSubsets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PSubsets& from);
  void MergeFrom(const PSubsets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool linked = 1;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 1;
  inline bool linked() const;
  inline void set_linked(bool value);

  // required .comphealth.ETYPE vtype = 2;
  inline bool has_vtype() const;
  inline void clear_vtype();
  static const int kVtypeFieldNumber = 2;
  inline ::comphealth::ETYPE vtype() const;
  inline void set_vtype(::comphealth::ETYPE value);

  // required .comphealth.AGG subset = 3;
  inline bool has_subset() const;
  inline void clear_subset();
  static const int kSubsetFieldNumber = 3;
  inline const ::comphealth::AGG& subset() const;
  inline ::comphealth::AGG* mutable_subset();
  inline ::comphealth::AGG* release_subset();
  inline void set_allocated_subset(::comphealth::AGG* subset);

  // optional string k = 4;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 4;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // @@protoc_insertion_point(class_scope:comphealth.PSubsets)
 private:
  inline void set_has_linked();
  inline void clear_has_linked();
  inline void set_has_vtype();
  inline void clear_has_vtype();
  inline void set_has_subset();
  inline void clear_has_subset();
  inline void set_has_k();
  inline void clear_has_k();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool linked_;
  int vtype_;
  ::comphealth::AGG* subset_;
  ::std::string* k_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static PSubsets* default_instance_;
};
// -------------------------------------------------------------------

class VisitDeltaHist : public ::google::protobuf::Message {
 public:
  VisitDeltaHist();
  virtual ~VisitDeltaHist();

  VisitDeltaHist(const VisitDeltaHist& from);

  inline VisitDeltaHist& operator=(const VisitDeltaHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisitDeltaHist& default_instance();

  void Swap(VisitDeltaHist* other);

  // implements Message ----------------------------------------------

  VisitDeltaHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisitDeltaHist& from);
  void MergeFrom(const VisitDeltaHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.ETYPE initial = 1;
  inline bool has_initial() const;
  inline void clear_initial();
  static const int kInitialFieldNumber = 1;
  inline ::comphealth::ETYPE initial() const;
  inline void set_initial(::comphealth::ETYPE value);

  // required .comphealth.ETYPE sub = 2;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 2;
  inline ::comphealth::ETYPE sub() const;
  inline void set_sub(::comphealth::ETYPE value);

  // required int32 delta = 3;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 3;
  inline ::google::protobuf::int32 delta() const;
  inline void set_delta(::google::protobuf::int32 value);

  // required int32 v = 4;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 4;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.VisitDeltaHist)
 private:
  inline void set_has_initial();
  inline void clear_has_initial();
  inline void set_has_sub();
  inline void clear_has_sub();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int initial_;
  int sub_;
  ::google::protobuf::int32 delta_;
  ::google::protobuf::int32 v_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static VisitDeltaHist* default_instance_;
};
// -------------------------------------------------------------------

class AGG : public ::google::protobuf::Message {
 public:
  AGG();
  virtual ~AGG();

  AGG(const AGG& from);

  inline AGG& operator=(const AGG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AGG& default_instance();

  void Swap(AGG* other);

  // implements Message ----------------------------------------------

  AGG* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AGG& from);
  void MergeFrom(const AGG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bool mini = 26 [default = false];
  inline bool has_mini() const;
  inline void clear_mini();
  static const int kMiniFieldNumber = 26;
  inline bool mini() const;
  inline void set_mini(bool value);

  // optional int32 count = 2 [default = 0];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required .comphealth.Policy policy = 33;
  inline bool has_policy() const;
  inline void clear_policy();
  static const int kPolicyFieldNumber = 33;
  inline const ::comphealth::Policy& policy() const;
  inline ::comphealth::Policy* mutable_policy();
  inline ::comphealth::Policy* release_policy();
  inline void set_allocated_policy(::comphealth::Policy* policy);

  // optional int64 charges_num = 31;
  inline bool has_charges_num() const;
  inline void clear_charges_num();
  static const int kChargesNumFieldNumber = 31;
  inline ::google::protobuf::int64 charges_num() const;
  inline void set_charges_num(::google::protobuf::int64 value);

  // optional int64 charges_den = 32;
  inline bool has_charges_den() const;
  inline void clear_charges_den();
  static const int kChargesDenFieldNumber = 32;
  inline ::google::protobuf::int64 charges_den() const;
  inline void set_charges_den(::google::protobuf::int64 value);

  // optional .comphealth.IntHist ageh = 3;
  inline bool has_ageh() const;
  inline void clear_ageh();
  static const int kAgehFieldNumber = 3;
  inline const ::comphealth::IntHist& ageh() const;
  inline ::comphealth::IntHist* mutable_ageh();
  inline ::comphealth::IntHist* release_ageh();
  inline void set_allocated_ageh(::comphealth::IntHist* ageh);

  // repeated .comphealth.SexHist sexh = 4;
  inline int sexh_size() const;
  inline void clear_sexh();
  static const int kSexhFieldNumber = 4;
  inline const ::comphealth::SexHist& sexh(int index) const;
  inline ::comphealth::SexHist* mutable_sexh(int index);
  inline ::comphealth::SexHist* add_sexh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SexHist >&
      sexh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::SexHist >*
      mutable_sexh();

  // repeated .comphealth.RaceHist raceh = 5;
  inline int raceh_size() const;
  inline void clear_raceh();
  static const int kRacehFieldNumber = 5;
  inline const ::comphealth::RaceHist& raceh(int index) const;
  inline ::comphealth::RaceHist* mutable_raceh(int index);
  inline ::comphealth::RaceHist* add_raceh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::RaceHist >&
      raceh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::RaceHist >*
      mutable_raceh();

  // repeated .comphealth.SourceHist sourceh = 6;
  inline int sourceh_size() const;
  inline void clear_sourceh();
  static const int kSourcehFieldNumber = 6;
  inline const ::comphealth::SourceHist& sourceh(int index) const;
  inline ::comphealth::SourceHist* mutable_sourceh(int index);
  inline ::comphealth::SourceHist* add_sourceh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SourceHist >&
      sourceh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::SourceHist >*
      mutable_sourceh();

  // repeated .comphealth.DispositionHist disph = 7;
  inline int disph_size() const;
  inline void clear_disph();
  static const int kDisphFieldNumber = 7;
  inline const ::comphealth::DispositionHist& disph(int index) const;
  inline ::comphealth::DispositionHist* mutable_disph(int index);
  inline ::comphealth::DispositionHist* add_disph();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DispositionHist >&
      disph() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::DispositionHist >*
      mutable_disph();

  // repeated .comphealth.PayerHist payerh = 8;
  inline int payerh_size() const;
  inline void clear_payerh();
  static const int kPayerhFieldNumber = 8;
  inline const ::comphealth::PayerHist& payerh(int index) const;
  inline ::comphealth::PayerHist* mutable_payerh(int index);
  inline ::comphealth::PayerHist* add_payerh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PayerHist >&
      payerh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::PayerHist >*
      mutable_payerh();

  // repeated .comphealth.DeathHist deathh = 9;
  inline int deathh_size() const;
  inline void clear_deathh();
  static const int kDeathhFieldNumber = 9;
  inline const ::comphealth::DeathHist& deathh(int index) const;
  inline ::comphealth::DeathHist* mutable_deathh(int index);
  inline ::comphealth::DeathHist* add_deathh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DeathHist >&
      deathh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::DeathHist >*
      mutable_deathh();

  // repeated .comphealth.DXI dxh = 10;
  inline int dxh_size() const;
  inline void clear_dxh();
  static const int kDxhFieldNumber = 10;
  inline const ::comphealth::DXI& dxh(int index) const;
  inline ::comphealth::DXI* mutable_dxh(int index);
  inline ::comphealth::DXI* add_dxh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DXI >&
      dxh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::DXI >*
      mutable_dxh();

  // repeated .comphealth.KVI primary_prh = 11;
  inline int primary_prh_size() const;
  inline void clear_primary_prh();
  static const int kPrimaryPrhFieldNumber = 11;
  inline const ::comphealth::KVI& primary_prh(int index) const;
  inline ::comphealth::KVI* mutable_primary_prh(int index);
  inline ::comphealth::KVI* add_primary_prh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
      primary_prh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
      mutable_primary_prh();

  // repeated .comphealth.KVI prh = 13;
  inline int prh_size() const;
  inline void clear_prh();
  static const int kPrhFieldNumber = 13;
  inline const ::comphealth::KVI& prh(int index) const;
  inline ::comphealth::KVI* mutable_prh(int index);
  inline ::comphealth::KVI* add_prh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
      prh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
      mutable_prh();

  // repeated .comphealth.KVI exh = 14;
  inline int exh_size() const;
  inline void clear_exh();
  static const int kExhFieldNumber = 14;
  inline const ::comphealth::KVI& exh(int index) const;
  inline ::comphealth::KVI* mutable_exh(int index);
  inline ::comphealth::KVI* add_exh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
      exh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
      mutable_exh();

  // repeated .comphealth.KVI drgh = 15;
  inline int drgh_size() const;
  inline void clear_drgh();
  static const int kDrghFieldNumber = 15;
  inline const ::comphealth::KVI& drgh(int index) const;
  inline ::comphealth::KVI* mutable_drgh(int index);
  inline ::comphealth::KVI* add_drgh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
      drgh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
      mutable_drgh();

  // optional .comphealth.IntHist losh = 16;
  inline bool has_losh() const;
  inline void clear_losh();
  static const int kLoshFieldNumber = 16;
  inline const ::comphealth::IntHist& losh() const;
  inline ::comphealth::IntHist* mutable_losh();
  inline ::comphealth::IntHist* release_losh();
  inline void set_allocated_losh(::comphealth::IntHist* losh);

  // repeated .comphealth.DNRHist dnrh = 18;
  inline int dnrh_size() const;
  inline void clear_dnrh();
  static const int kDnrhFieldNumber = 18;
  inline const ::comphealth::DNRHist& dnrh(int index) const;
  inline ::comphealth::DNRHist* mutable_dnrh(int index);
  inline ::comphealth::DNRHist* add_dnrh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DNRHist >&
      dnrh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::DNRHist >*
      mutable_dnrh();

  // repeated .comphealth.PZipHist pziph = 19;
  inline int pziph_size() const;
  inline void clear_pziph();
  static const int kPziphFieldNumber = 19;
  inline const ::comphealth::PZipHist& pziph(int index) const;
  inline ::comphealth::PZipHist* mutable_pziph(int index);
  inline ::comphealth::PZipHist* add_pziph();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PZipHist >&
      pziph() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::PZipHist >*
      mutable_pziph();

  // repeated .comphealth.KVII agedh = 21;
  inline int agedh_size() const;
  inline void clear_agedh();
  static const int kAgedhFieldNumber = 21;
  inline const ::comphealth::KVII& agedh(int index) const;
  inline ::comphealth::KVII* mutable_agedh(int index);
  inline ::comphealth::KVII* add_agedh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
      agedh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
      mutable_agedh();

  // repeated .comphealth.KVII yearh = 22;
  inline int yearh_size() const;
  inline void clear_yearh();
  static const int kYearhFieldNumber = 22;
  inline const ::comphealth::KVII& yearh(int index) const;
  inline ::comphealth::KVII* mutable_yearh(int index);
  inline ::comphealth::KVII* add_yearh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
      yearh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
      mutable_yearh();

  // repeated .comphealth.EtypeHist vtypeh = 23;
  inline int vtypeh_size() const;
  inline void clear_vtypeh();
  static const int kVtypehFieldNumber = 23;
  inline const ::comphealth::EtypeHist& vtypeh(int index) const;
  inline ::comphealth::EtypeHist* mutable_vtypeh(int index);
  inline ::comphealth::EtypeHist* add_vtypeh();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeHist >&
      vtypeh() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeHist >*
      mutable_vtypeh();

  // repeated string facilityh = 24;
  inline int facilityh_size() const;
  inline void clear_facilityh();
  static const int kFacilityhFieldNumber = 24;
  inline const ::std::string& facilityh(int index) const;
  inline ::std::string* mutable_facilityh(int index);
  inline void set_facilityh(int index, const ::std::string& value);
  inline void set_facilityh(int index, const char* value);
  inline void set_facilityh(int index, const char* value, size_t size);
  inline ::std::string* add_facilityh();
  inline void add_facilityh(const ::std::string& value);
  inline void add_facilityh(const char* value);
  inline void add_facilityh(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& facilityh() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_facilityh();

  // optional string dataset = 25;
  inline bool has_dataset() const;
  inline void clear_dataset();
  static const int kDatasetFieldNumber = 25;
  inline const ::std::string& dataset() const;
  inline void set_dataset(const ::std::string& value);
  inline void set_dataset(const char* value);
  inline void set_dataset(const char* value, size_t size);
  inline ::std::string* mutable_dataset();
  inline ::std::string* release_dataset();
  inline void set_allocated_dataset(::std::string* dataset);

  // @@protoc_insertion_point(class_scope:comphealth.AGG)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_mini();
  inline void clear_has_mini();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_policy();
  inline void clear_has_policy();
  inline void set_has_charges_num();
  inline void clear_has_charges_num();
  inline void set_has_charges_den();
  inline void clear_has_charges_den();
  inline void set_has_ageh();
  inline void clear_has_ageh();
  inline void set_has_losh();
  inline void clear_has_losh();
  inline void set_has_dataset();
  inline void clear_has_dataset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  bool mini_;
  ::google::protobuf::int32 count_;
  ::comphealth::Policy* policy_;
  ::google::protobuf::int64 charges_num_;
  ::google::protobuf::int64 charges_den_;
  ::comphealth::IntHist* ageh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::SexHist > sexh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::RaceHist > raceh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::SourceHist > sourceh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::DispositionHist > disph_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::PayerHist > payerh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::DeathHist > deathh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::DXI > dxh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVI > primary_prh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVI > prh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVI > exh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVI > drgh_;
  ::comphealth::IntHist* losh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::DNRHist > dnrh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::PZipHist > pziph_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVII > agedh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVII > yearh_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeHist > vtypeh_;
  ::google::protobuf::RepeatedPtrField< ::std::string> facilityh_;
  ::std::string* dataset_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static AGG* default_instance_;
};
// -------------------------------------------------------------------

class Policy : public ::google::protobuf::Message {
 public:
  Policy();
  virtual ~Policy();

  Policy(const Policy& from);

  inline Policy& operator=(const Policy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Policy& default_instance();

  void Swap(Policy* other);

  // implements Message ----------------------------------------------

  Policy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Policy& from);
  void MergeFrom(const Policy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 min_count = 1;
  inline bool has_min_count() const;
  inline void clear_min_count();
  static const int kMinCountFieldNumber = 1;
  inline ::google::protobuf::int32 min_count() const;
  inline void set_min_count(::google::protobuf::int32 value);

  // required int32 min_hospital = 2;
  inline bool has_min_hospital() const;
  inline void clear_min_hospital();
  static const int kMinHospitalFieldNumber = 2;
  inline ::google::protobuf::int32 min_hospital() const;
  inline void set_min_hospital(::google::protobuf::int32 value);

  // required int32 base = 3;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 3;
  inline ::google::protobuf::int32 base() const;
  inline void set_base(::google::protobuf::int32 value);

  // required int32 min_subset = 4;
  inline bool has_min_subset() const;
  inline void clear_min_subset();
  static const int kMinSubsetFieldNumber = 4;
  inline ::google::protobuf::int32 min_subset() const;
  inline void set_min_subset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.Policy)
 private:
  inline void set_has_min_count();
  inline void clear_has_min_count();
  inline void set_has_min_hospital();
  inline void clear_has_min_hospital();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_min_subset();
  inline void clear_has_min_subset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 min_count_;
  ::google::protobuf::int32 min_hospital_;
  ::google::protobuf::int32 base_;
  ::google::protobuf::int32 min_subset_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static Policy* default_instance_;
};
// -------------------------------------------------------------------

class IntHist : public ::google::protobuf::Message {
 public:
  IntHist();
  virtual ~IntHist();

  IntHist(const IntHist& from);

  inline IntHist& operator=(const IntHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntHist& default_instance();

  void Swap(IntHist* other);

  // implements Message ----------------------------------------------

  IntHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntHist& from);
  void MergeFrom(const IntHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .comphealth.KVII h = 1;
  inline int h_size() const;
  inline void clear_h();
  static const int kHFieldNumber = 1;
  inline const ::comphealth::KVII& h(int index) const;
  inline ::comphealth::KVII* mutable_h(int index);
  inline ::comphealth::KVII* add_h();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
      h() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
      mutable_h();

  // optional int32 median = 2;
  inline bool has_median() const;
  inline void clear_median();
  static const int kMedianFieldNumber = 2;
  inline ::google::protobuf::int32 median() const;
  inline void set_median(::google::protobuf::int32 value);

  // optional int32 fq = 3;
  inline bool has_fq() const;
  inline void clear_fq();
  static const int kFqFieldNumber = 3;
  inline ::google::protobuf::int32 fq() const;
  inline void set_fq(::google::protobuf::int32 value);

  // optional int32 tq = 4;
  inline bool has_tq() const;
  inline void clear_tq();
  static const int kTqFieldNumber = 4;
  inline ::google::protobuf::int32 tq() const;
  inline void set_tq(::google::protobuf::int32 value);

  // optional float mean = 5;
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 5;
  inline float mean() const;
  inline void set_mean(float value);

  // @@protoc_insertion_point(class_scope:comphealth.IntHist)
 private:
  inline void set_has_median();
  inline void clear_has_median();
  inline void set_has_fq();
  inline void clear_has_fq();
  inline void set_has_tq();
  inline void clear_has_tq();
  inline void set_has_mean();
  inline void clear_has_mean();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::KVII > h_;
  ::google::protobuf::int32 median_;
  ::google::protobuf::int32 fq_;
  ::google::protobuf::int32 tq_;
  float mean_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static IntHist* default_instance_;
};
// -------------------------------------------------------------------

class KVII : public ::google::protobuf::Message {
 public:
  KVII();
  virtual ~KVII();

  KVII(const KVII& from);

  inline KVII& operator=(const KVII& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVII& default_instance();

  void Swap(KVII* other);

  // implements Message ----------------------------------------------

  KVII* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVII& from);
  void MergeFrom(const KVII& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::google::protobuf::int32 k() const;
  inline void set_k(::google::protobuf::int32 value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.KVII)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static KVII* default_instance_;
};
// -------------------------------------------------------------------

class DXI : public ::google::protobuf::Message {
 public:
  DXI();
  virtual ~DXI();

  DXI(const DXI& from);

  inline DXI& operator=(const DXI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DXI& default_instance();

  void Swap(DXI* other);

  // implements Message ----------------------------------------------

  DXI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DXI& from);
  void MergeFrom(const DXI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const char* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // optional int32 primary = 2;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 2;
  inline ::google::protobuf::int32 primary() const;
  inline void set_primary(::google::protobuf::int32 value);

  // optional int32 poa = 3;
  inline bool has_poa() const;
  inline void clear_poa();
  static const int kPoaFieldNumber = 3;
  inline ::google::protobuf::int32 poa() const;
  inline void set_poa(::google::protobuf::int32 value);

  // optional int32 all = 4;
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 4;
  inline ::google::protobuf::int32 all() const;
  inline void set_all(::google::protobuf::int32 value);

  // optional string c = 5;
  inline bool has_c() const;
  inline void clear_c();
  static const int kCFieldNumber = 5;
  inline const ::std::string& c() const;
  inline void set_c(const ::std::string& value);
  inline void set_c(const char* value);
  inline void set_c(const char* value, size_t size);
  inline ::std::string* mutable_c();
  inline ::std::string* release_c();
  inline void set_allocated_c(::std::string* c);

  // optional string s = 6;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 6;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.DXI)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_primary();
  inline void clear_has_primary();
  inline void set_has_poa();
  inline void clear_has_poa();
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_c();
  inline void clear_has_c();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::google::protobuf::int32 primary_;
  ::google::protobuf::int32 poa_;
  ::std::string* c_;
  ::std::string* s_;
  ::google::protobuf::int32 all_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static DXI* default_instance_;
};
// -------------------------------------------------------------------

class DispositionHist : public ::google::protobuf::Message {
 public:
  DispositionHist();
  virtual ~DispositionHist();

  DispositionHist(const DispositionHist& from);

  inline DispositionHist& operator=(const DispositionHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DispositionHist& default_instance();

  void Swap(DispositionHist* other);

  // implements Message ----------------------------------------------

  DispositionHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DispositionHist& from);
  void MergeFrom(const DispositionHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.DISPOSITION k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::DISPOSITION k() const;
  inline void set_k(::comphealth::DISPOSITION value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.DispositionHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static DispositionHist* default_instance_;
};
// -------------------------------------------------------------------

class EtypeHist : public ::google::protobuf::Message {
 public:
  EtypeHist();
  virtual ~EtypeHist();

  EtypeHist(const EtypeHist& from);

  inline EtypeHist& operator=(const EtypeHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EtypeHist& default_instance();

  void Swap(EtypeHist* other);

  // implements Message ----------------------------------------------

  EtypeHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EtypeHist& from);
  void MergeFrom(const EtypeHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.ETYPE k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::ETYPE k() const;
  inline void set_k(::comphealth::ETYPE value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.EtypeHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static EtypeHist* default_instance_;
};
// -------------------------------------------------------------------

class EtypeCountHist : public ::google::protobuf::Message {
 public:
  EtypeCountHist();
  virtual ~EtypeCountHist();

  EtypeCountHist(const EtypeCountHist& from);

  inline EtypeCountHist& operator=(const EtypeCountHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EtypeCountHist& default_instance();

  void Swap(EtypeCountHist* other);

  // implements Message ----------------------------------------------

  EtypeCountHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EtypeCountHist& from);
  void MergeFrom(const EtypeCountHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool linked = 5;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 5;
  inline bool linked() const;
  inline void set_linked(bool value);

  // required int32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::int32 ip() const;
  inline void set_ip(::google::protobuf::int32 value);

  // required int32 ed = 2;
  inline bool has_ed() const;
  inline void clear_ed();
  static const int kEdFieldNumber = 2;
  inline ::google::protobuf::int32 ed() const;
  inline void set_ed(::google::protobuf::int32 value);

  // required int32 asg = 3;
  inline bool has_asg() const;
  inline void clear_asg();
  static const int kAsgFieldNumber = 3;
  inline ::google::protobuf::int32 asg() const;
  inline void set_asg(::google::protobuf::int32 value);

  // required int32 v = 4;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 4;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.EtypeCountHist)
 private:
  inline void set_has_linked();
  inline void clear_has_linked();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_ed();
  inline void clear_has_ed();
  inline void set_has_asg();
  inline void clear_has_asg();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool linked_;
  ::google::protobuf::int32 ip_;
  ::google::protobuf::int32 ed_;
  ::google::protobuf::int32 asg_;
  ::google::protobuf::int32 v_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static EtypeCountHist* default_instance_;
};
// -------------------------------------------------------------------

class SourceHist : public ::google::protobuf::Message {
 public:
  SourceHist();
  virtual ~SourceHist();

  SourceHist(const SourceHist& from);

  inline SourceHist& operator=(const SourceHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SourceHist& default_instance();

  void Swap(SourceHist* other);

  // implements Message ----------------------------------------------

  SourceHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SourceHist& from);
  void MergeFrom(const SourceHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.SOURCE k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::SOURCE k() const;
  inline void set_k(::comphealth::SOURCE value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.SourceHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static SourceHist* default_instance_;
};
// -------------------------------------------------------------------

class PayerHist : public ::google::protobuf::Message {
 public:
  PayerHist();
  virtual ~PayerHist();

  PayerHist(const PayerHist& from);

  inline PayerHist& operator=(const PayerHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayerHist& default_instance();

  void Swap(PayerHist* other);

  // implements Message ----------------------------------------------

  PayerHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayerHist& from);
  void MergeFrom(const PayerHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.PAYER k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::PAYER k() const;
  inline void set_k(::comphealth::PAYER value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.PayerHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static PayerHist* default_instance_;
};
// -------------------------------------------------------------------

class RaceHist : public ::google::protobuf::Message {
 public:
  RaceHist();
  virtual ~RaceHist();

  RaceHist(const RaceHist& from);

  inline RaceHist& operator=(const RaceHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaceHist& default_instance();

  void Swap(RaceHist* other);

  // implements Message ----------------------------------------------

  RaceHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaceHist& from);
  void MergeFrom(const RaceHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.RACE k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::RACE k() const;
  inline void set_k(::comphealth::RACE value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.RaceHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static RaceHist* default_instance_;
};
// -------------------------------------------------------------------

class DeathHist : public ::google::protobuf::Message {
 public:
  DeathHist();
  virtual ~DeathHist();

  DeathHist(const DeathHist& from);

  inline DeathHist& operator=(const DeathHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeathHist& default_instance();

  void Swap(DeathHist* other);

  // implements Message ----------------------------------------------

  DeathHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeathHist& from);
  void MergeFrom(const DeathHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.DEATH k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::DEATH k() const;
  inline void set_k(::comphealth::DEATH value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.DeathHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static DeathHist* default_instance_;
};
// -------------------------------------------------------------------

class SexHist : public ::google::protobuf::Message {
 public:
  SexHist();
  virtual ~SexHist();

  SexHist(const SexHist& from);

  inline SexHist& operator=(const SexHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SexHist& default_instance();

  void Swap(SexHist* other);

  // implements Message ----------------------------------------------

  SexHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SexHist& from);
  void MergeFrom(const SexHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.SEX k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::SEX k() const;
  inline void set_k(::comphealth::SEX value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.SexHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static SexHist* default_instance_;
};
// -------------------------------------------------------------------

class DNRHist : public ::google::protobuf::Message {
 public:
  DNRHist();
  virtual ~DNRHist();

  DNRHist(const DNRHist& from);

  inline DNRHist& operator=(const DNRHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DNRHist& default_instance();

  void Swap(DNRHist* other);

  // implements Message ----------------------------------------------

  DNRHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DNRHist& from);
  void MergeFrom(const DNRHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.DNR k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::DNR k() const;
  inline void set_k(::comphealth::DNR value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.DNRHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static DNRHist* default_instance_;
};
// -------------------------------------------------------------------

class PZipHist : public ::google::protobuf::Message {
 public:
  PZipHist();
  virtual ~PZipHist();

  PZipHist(const PZipHist& from);

  inline PZipHist& operator=(const PZipHist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PZipHist& default_instance();

  void Swap(PZipHist* other);

  // implements Message ----------------------------------------------

  PZipHist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PZipHist& from);
  void MergeFrom(const PZipHist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.PZIP k = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline ::comphealth::PZIP k() const;
  inline void set_k(::comphealth::PZIP value);

  // required int32 v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // optional string s = 3;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 3;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:comphealth.PZipHist)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int k_;
  ::google::protobuf::int32 v_;
  ::std::string* s_;
  friend void  protobuf_AddDesc_pstat_2eproto();
  friend void protobuf_AssignDesc_pstat_2eproto();
  friend void protobuf_ShutdownFile_pstat_2eproto();

  void InitAsDefaultInstance();
  static PZipHist* default_instance_;
};
// ===================================================================


// ===================================================================

// PAGG

// required string key = 1;
inline bool PAGG::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PAGG::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PAGG::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PAGG::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PAGG::key() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.key)
  return *key_;
}
inline void PAGG::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PAGG.key)
}
inline void PAGG::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PAGG.key)
}
inline void PAGG::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PAGG.key)
}
inline ::std::string* PAGG::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.key)
  return key_;
}
inline ::std::string* PAGG::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PAGG::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PAGG.key)
}

// optional string dataset = 2;
inline bool PAGG::has_dataset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PAGG::set_has_dataset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PAGG::clear_has_dataset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PAGG::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& PAGG::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.dataset)
  return *dataset_;
}
inline void PAGG::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PAGG.dataset)
}
inline void PAGG::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PAGG.dataset)
}
inline void PAGG::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PAGG.dataset)
}
inline ::std::string* PAGG::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.dataset)
  return dataset_;
}
inline ::std::string* PAGG::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PAGG::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PAGG.dataset)
}

// required bool linked = 3;
inline bool PAGG::has_linked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PAGG::set_has_linked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PAGG::clear_has_linked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PAGG::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool PAGG::linked() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.linked)
  return linked_;
}
inline void PAGG::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.linked)
}

// required bool unlinked = 4;
inline bool PAGG::has_unlinked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PAGG::set_has_unlinked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PAGG::clear_has_unlinked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PAGG::clear_unlinked() {
  unlinked_ = false;
  clear_has_unlinked();
}
inline bool PAGG::unlinked() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.unlinked)
  return unlinked_;
}
inline void PAGG::set_unlinked(bool value) {
  set_has_unlinked();
  unlinked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.unlinked)
}

// required int32 patient_count = 6;
inline bool PAGG::has_patient_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PAGG::set_has_patient_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PAGG::clear_has_patient_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PAGG::clear_patient_count() {
  patient_count_ = 0;
  clear_has_patient_count();
}
inline ::google::protobuf::int32 PAGG::patient_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.patient_count)
  return patient_count_;
}
inline void PAGG::set_patient_count(::google::protobuf::int32 value) {
  set_has_patient_count();
  patient_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.patient_count)
}

// required int32 visit_count = 7;
inline bool PAGG::has_visit_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PAGG::set_has_visit_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PAGG::clear_has_visit_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PAGG::clear_visit_count() {
  visit_count_ = 0;
  clear_has_visit_count();
}
inline ::google::protobuf::int32 PAGG::visit_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.visit_count)
  return visit_count_;
}
inline void PAGG::set_visit_count(::google::protobuf::int32 value) {
  set_has_visit_count();
  visit_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.visit_count)
}

// required int32 linked_count = 8;
inline bool PAGG::has_linked_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PAGG::set_has_linked_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PAGG::clear_has_linked_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PAGG::clear_linked_count() {
  linked_count_ = 0;
  clear_has_linked_count();
}
inline ::google::protobuf::int32 PAGG::linked_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.linked_count)
  return linked_count_;
}
inline void PAGG::set_linked_count(::google::protobuf::int32 value) {
  set_has_linked_count();
  linked_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.linked_count)
}

// required int32 unlinked_count = 9;
inline bool PAGG::has_unlinked_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PAGG::set_has_unlinked_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PAGG::clear_has_unlinked_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PAGG::clear_unlinked_count() {
  unlinked_count_ = 0;
  clear_has_unlinked_count();
}
inline ::google::protobuf::int32 PAGG::unlinked_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.unlinked_count)
  return unlinked_count_;
}
inline void PAGG::set_unlinked_count(::google::protobuf::int32 value) {
  set_has_unlinked_count();
  unlinked_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.unlinked_count)
}

// repeated .comphealth.PSubsets subsets = 10;
inline int PAGG::subsets_size() const {
  return subsets_.size();
}
inline void PAGG::clear_subsets() {
  subsets_.Clear();
}
inline const ::comphealth::PSubsets& PAGG::subsets(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.subsets)
  return subsets_.Get(index);
}
inline ::comphealth::PSubsets* PAGG::mutable_subsets(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.subsets)
  return subsets_.Mutable(index);
}
inline ::comphealth::PSubsets* PAGG::add_subsets() {
  // @@protoc_insertion_point(field_add:comphealth.PAGG.subsets)
  return subsets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PSubsets >&
PAGG::subsets() const {
  // @@protoc_insertion_point(field_list:comphealth.PAGG.subsets)
  return subsets_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::PSubsets >*
PAGG::mutable_subsets() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PAGG.subsets)
  return &subsets_;
}

// repeated .comphealth.VisitDeltaHist delta_hist = 11;
inline int PAGG::delta_hist_size() const {
  return delta_hist_.size();
}
inline void PAGG::clear_delta_hist() {
  delta_hist_.Clear();
}
inline const ::comphealth::VisitDeltaHist& PAGG::delta_hist(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.delta_hist)
  return delta_hist_.Get(index);
}
inline ::comphealth::VisitDeltaHist* PAGG::mutable_delta_hist(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.delta_hist)
  return delta_hist_.Mutable(index);
}
inline ::comphealth::VisitDeltaHist* PAGG::add_delta_hist() {
  // @@protoc_insertion_point(field_add:comphealth.PAGG.delta_hist)
  return delta_hist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >&
PAGG::delta_hist() const {
  // @@protoc_insertion_point(field_list:comphealth.PAGG.delta_hist)
  return delta_hist_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >*
PAGG::mutable_delta_hist() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PAGG.delta_hist)
  return &delta_hist_;
}

// repeated .comphealth.VisitDeltaHist delta_error_hist = 13;
inline int PAGG::delta_error_hist_size() const {
  return delta_error_hist_.size();
}
inline void PAGG::clear_delta_error_hist() {
  delta_error_hist_.Clear();
}
inline const ::comphealth::VisitDeltaHist& PAGG::delta_error_hist(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.delta_error_hist)
  return delta_error_hist_.Get(index);
}
inline ::comphealth::VisitDeltaHist* PAGG::mutable_delta_error_hist(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.delta_error_hist)
  return delta_error_hist_.Mutable(index);
}
inline ::comphealth::VisitDeltaHist* PAGG::add_delta_error_hist() {
  // @@protoc_insertion_point(field_add:comphealth.PAGG.delta_error_hist)
  return delta_error_hist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >&
PAGG::delta_error_hist() const {
  // @@protoc_insertion_point(field_list:comphealth.PAGG.delta_error_hist)
  return delta_error_hist_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::VisitDeltaHist >*
PAGG::mutable_delta_error_hist() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PAGG.delta_error_hist)
  return &delta_error_hist_;
}

// repeated .comphealth.EtypeCountHist count_hist = 12;
inline int PAGG::count_hist_size() const {
  return count_hist_.size();
}
inline void PAGG::clear_count_hist() {
  count_hist_.Clear();
}
inline const ::comphealth::EtypeCountHist& PAGG::count_hist(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.count_hist)
  return count_hist_.Get(index);
}
inline ::comphealth::EtypeCountHist* PAGG::mutable_count_hist(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.count_hist)
  return count_hist_.Mutable(index);
}
inline ::comphealth::EtypeCountHist* PAGG::add_count_hist() {
  // @@protoc_insertion_point(field_add:comphealth.PAGG.count_hist)
  return count_hist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeCountHist >&
PAGG::count_hist() const {
  // @@protoc_insertion_point(field_list:comphealth.PAGG.count_hist)
  return count_hist_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeCountHist >*
PAGG::mutable_count_hist() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PAGG.count_hist)
  return &count_hist_;
}

// optional int32 edge_count = 14;
inline bool PAGG::has_edge_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PAGG::set_has_edge_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PAGG::clear_has_edge_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PAGG::clear_edge_count() {
  edge_count_ = 0;
  clear_has_edge_count();
}
inline ::google::protobuf::int32 PAGG::edge_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.edge_count)
  return edge_count_;
}
inline void PAGG::set_edge_count(::google::protobuf::int32 value) {
  set_has_edge_count();
  edge_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.edge_count)
}

// optional int32 negative_delta_count = 15;
inline bool PAGG::has_negative_delta_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PAGG::set_has_negative_delta_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PAGG::clear_has_negative_delta_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PAGG::clear_negative_delta_count() {
  negative_delta_count_ = 0;
  clear_has_negative_delta_count();
}
inline ::google::protobuf::int32 PAGG::negative_delta_count() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.negative_delta_count)
  return negative_delta_count_;
}
inline void PAGG::set_negative_delta_count(::google::protobuf::int32 value) {
  set_has_negative_delta_count();
  negative_delta_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PAGG.negative_delta_count)
}

// required .comphealth.Policy policy = 16;
inline bool PAGG::has_policy() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PAGG::set_has_policy() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PAGG::clear_has_policy() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PAGG::clear_policy() {
  if (policy_ != NULL) policy_->::comphealth::Policy::Clear();
  clear_has_policy();
}
inline const ::comphealth::Policy& PAGG::policy() const {
  // @@protoc_insertion_point(field_get:comphealth.PAGG.policy)
  return policy_ != NULL ? *policy_ : *default_instance_->policy_;
}
inline ::comphealth::Policy* PAGG::mutable_policy() {
  set_has_policy();
  if (policy_ == NULL) policy_ = new ::comphealth::Policy;
  // @@protoc_insertion_point(field_mutable:comphealth.PAGG.policy)
  return policy_;
}
inline ::comphealth::Policy* PAGG::release_policy() {
  clear_has_policy();
  ::comphealth::Policy* temp = policy_;
  policy_ = NULL;
  return temp;
}
inline void PAGG::set_allocated_policy(::comphealth::Policy* policy) {
  delete policy_;
  policy_ = policy;
  if (policy) {
    set_has_policy();
  } else {
    clear_has_policy();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PAGG.policy)
}

// -------------------------------------------------------------------

// PSubsets

// required bool linked = 1;
inline bool PSubsets::has_linked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PSubsets::set_has_linked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PSubsets::clear_has_linked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PSubsets::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool PSubsets::linked() const {
  // @@protoc_insertion_point(field_get:comphealth.PSubsets.linked)
  return linked_;
}
inline void PSubsets::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PSubsets.linked)
}

// required .comphealth.ETYPE vtype = 2;
inline bool PSubsets::has_vtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PSubsets::set_has_vtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PSubsets::clear_has_vtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PSubsets::clear_vtype() {
  vtype_ = 0;
  clear_has_vtype();
}
inline ::comphealth::ETYPE PSubsets::vtype() const {
  // @@protoc_insertion_point(field_get:comphealth.PSubsets.vtype)
  return static_cast< ::comphealth::ETYPE >(vtype_);
}
inline void PSubsets::set_vtype(::comphealth::ETYPE value) {
  assert(::comphealth::ETYPE_IsValid(value));
  set_has_vtype();
  vtype_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PSubsets.vtype)
}

// required .comphealth.AGG subset = 3;
inline bool PSubsets::has_subset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PSubsets::set_has_subset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PSubsets::clear_has_subset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PSubsets::clear_subset() {
  if (subset_ != NULL) subset_->::comphealth::AGG::Clear();
  clear_has_subset();
}
inline const ::comphealth::AGG& PSubsets::subset() const {
  // @@protoc_insertion_point(field_get:comphealth.PSubsets.subset)
  return subset_ != NULL ? *subset_ : *default_instance_->subset_;
}
inline ::comphealth::AGG* PSubsets::mutable_subset() {
  set_has_subset();
  if (subset_ == NULL) subset_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.PSubsets.subset)
  return subset_;
}
inline ::comphealth::AGG* PSubsets::release_subset() {
  clear_has_subset();
  ::comphealth::AGG* temp = subset_;
  subset_ = NULL;
  return temp;
}
inline void PSubsets::set_allocated_subset(::comphealth::AGG* subset) {
  delete subset_;
  subset_ = subset;
  if (subset) {
    set_has_subset();
  } else {
    clear_has_subset();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PSubsets.subset)
}

// optional string k = 4;
inline bool PSubsets::has_k() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PSubsets::set_has_k() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PSubsets::clear_has_k() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PSubsets::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& PSubsets::k() const {
  // @@protoc_insertion_point(field_get:comphealth.PSubsets.k)
  return *k_;
}
inline void PSubsets::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PSubsets.k)
}
inline void PSubsets::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PSubsets.k)
}
inline void PSubsets::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PSubsets.k)
}
inline ::std::string* PSubsets::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PSubsets.k)
  return k_;
}
inline ::std::string* PSubsets::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PSubsets::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PSubsets.k)
}

// -------------------------------------------------------------------

// VisitDeltaHist

// required .comphealth.ETYPE initial = 1;
inline bool VisitDeltaHist::has_initial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisitDeltaHist::set_has_initial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisitDeltaHist::clear_has_initial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisitDeltaHist::clear_initial() {
  initial_ = 0;
  clear_has_initial();
}
inline ::comphealth::ETYPE VisitDeltaHist::initial() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitDeltaHist.initial)
  return static_cast< ::comphealth::ETYPE >(initial_);
}
inline void VisitDeltaHist::set_initial(::comphealth::ETYPE value) {
  assert(::comphealth::ETYPE_IsValid(value));
  set_has_initial();
  initial_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VisitDeltaHist.initial)
}

// required .comphealth.ETYPE sub = 2;
inline bool VisitDeltaHist::has_sub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisitDeltaHist::set_has_sub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisitDeltaHist::clear_has_sub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisitDeltaHist::clear_sub() {
  sub_ = 0;
  clear_has_sub();
}
inline ::comphealth::ETYPE VisitDeltaHist::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitDeltaHist.sub)
  return static_cast< ::comphealth::ETYPE >(sub_);
}
inline void VisitDeltaHist::set_sub(::comphealth::ETYPE value) {
  assert(::comphealth::ETYPE_IsValid(value));
  set_has_sub();
  sub_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VisitDeltaHist.sub)
}

// required int32 delta = 3;
inline bool VisitDeltaHist::has_delta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VisitDeltaHist::set_has_delta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VisitDeltaHist::clear_has_delta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VisitDeltaHist::clear_delta() {
  delta_ = 0;
  clear_has_delta();
}
inline ::google::protobuf::int32 VisitDeltaHist::delta() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitDeltaHist.delta)
  return delta_;
}
inline void VisitDeltaHist::set_delta(::google::protobuf::int32 value) {
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VisitDeltaHist.delta)
}

// required int32 v = 4;
inline bool VisitDeltaHist::has_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VisitDeltaHist::set_has_v() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VisitDeltaHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VisitDeltaHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 VisitDeltaHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.VisitDeltaHist.v)
  return v_;
}
inline void VisitDeltaHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.VisitDeltaHist.v)
}

// -------------------------------------------------------------------

// AGG

// required string key = 1;
inline bool AGG::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AGG::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AGG::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AGG::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AGG::key() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.key)
  return *key_;
}
inline void AGG::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.AGG.key)
}
inline void AGG::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.AGG.key)
}
inline void AGG::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.AGG.key)
}
inline ::std::string* AGG::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.key)
  return key_;
}
inline ::std::string* AGG::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AGG::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.AGG.key)
}

// required bool mini = 26 [default = false];
inline bool AGG::has_mini() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AGG::set_has_mini() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AGG::clear_has_mini() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AGG::clear_mini() {
  mini_ = false;
  clear_has_mini();
}
inline bool AGG::mini() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.mini)
  return mini_;
}
inline void AGG::set_mini(bool value) {
  set_has_mini();
  mini_ = value;
  // @@protoc_insertion_point(field_set:comphealth.AGG.mini)
}

// optional int32 count = 2 [default = 0];
inline bool AGG::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AGG::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AGG::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AGG::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 AGG::count() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.count)
  return count_;
}
inline void AGG::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.AGG.count)
}

// required .comphealth.Policy policy = 33;
inline bool AGG::has_policy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AGG::set_has_policy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AGG::clear_has_policy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AGG::clear_policy() {
  if (policy_ != NULL) policy_->::comphealth::Policy::Clear();
  clear_has_policy();
}
inline const ::comphealth::Policy& AGG::policy() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.policy)
  return policy_ != NULL ? *policy_ : *default_instance_->policy_;
}
inline ::comphealth::Policy* AGG::mutable_policy() {
  set_has_policy();
  if (policy_ == NULL) policy_ = new ::comphealth::Policy;
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.policy)
  return policy_;
}
inline ::comphealth::Policy* AGG::release_policy() {
  clear_has_policy();
  ::comphealth::Policy* temp = policy_;
  policy_ = NULL;
  return temp;
}
inline void AGG::set_allocated_policy(::comphealth::Policy* policy) {
  delete policy_;
  policy_ = policy;
  if (policy) {
    set_has_policy();
  } else {
    clear_has_policy();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.AGG.policy)
}

// optional int64 charges_num = 31;
inline bool AGG::has_charges_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AGG::set_has_charges_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AGG::clear_has_charges_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AGG::clear_charges_num() {
  charges_num_ = GOOGLE_LONGLONG(0);
  clear_has_charges_num();
}
inline ::google::protobuf::int64 AGG::charges_num() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.charges_num)
  return charges_num_;
}
inline void AGG::set_charges_num(::google::protobuf::int64 value) {
  set_has_charges_num();
  charges_num_ = value;
  // @@protoc_insertion_point(field_set:comphealth.AGG.charges_num)
}

// optional int64 charges_den = 32;
inline bool AGG::has_charges_den() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AGG::set_has_charges_den() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AGG::clear_has_charges_den() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AGG::clear_charges_den() {
  charges_den_ = GOOGLE_LONGLONG(0);
  clear_has_charges_den();
}
inline ::google::protobuf::int64 AGG::charges_den() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.charges_den)
  return charges_den_;
}
inline void AGG::set_charges_den(::google::protobuf::int64 value) {
  set_has_charges_den();
  charges_den_ = value;
  // @@protoc_insertion_point(field_set:comphealth.AGG.charges_den)
}

// optional .comphealth.IntHist ageh = 3;
inline bool AGG::has_ageh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AGG::set_has_ageh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AGG::clear_has_ageh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AGG::clear_ageh() {
  if (ageh_ != NULL) ageh_->::comphealth::IntHist::Clear();
  clear_has_ageh();
}
inline const ::comphealth::IntHist& AGG::ageh() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.ageh)
  return ageh_ != NULL ? *ageh_ : *default_instance_->ageh_;
}
inline ::comphealth::IntHist* AGG::mutable_ageh() {
  set_has_ageh();
  if (ageh_ == NULL) ageh_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.ageh)
  return ageh_;
}
inline ::comphealth::IntHist* AGG::release_ageh() {
  clear_has_ageh();
  ::comphealth::IntHist* temp = ageh_;
  ageh_ = NULL;
  return temp;
}
inline void AGG::set_allocated_ageh(::comphealth::IntHist* ageh) {
  delete ageh_;
  ageh_ = ageh;
  if (ageh) {
    set_has_ageh();
  } else {
    clear_has_ageh();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.AGG.ageh)
}

// repeated .comphealth.SexHist sexh = 4;
inline int AGG::sexh_size() const {
  return sexh_.size();
}
inline void AGG::clear_sexh() {
  sexh_.Clear();
}
inline const ::comphealth::SexHist& AGG::sexh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.sexh)
  return sexh_.Get(index);
}
inline ::comphealth::SexHist* AGG::mutable_sexh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.sexh)
  return sexh_.Mutable(index);
}
inline ::comphealth::SexHist* AGG::add_sexh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.sexh)
  return sexh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SexHist >&
AGG::sexh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.sexh)
  return sexh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::SexHist >*
AGG::mutable_sexh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.sexh)
  return &sexh_;
}

// repeated .comphealth.RaceHist raceh = 5;
inline int AGG::raceh_size() const {
  return raceh_.size();
}
inline void AGG::clear_raceh() {
  raceh_.Clear();
}
inline const ::comphealth::RaceHist& AGG::raceh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.raceh)
  return raceh_.Get(index);
}
inline ::comphealth::RaceHist* AGG::mutable_raceh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.raceh)
  return raceh_.Mutable(index);
}
inline ::comphealth::RaceHist* AGG::add_raceh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.raceh)
  return raceh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::RaceHist >&
AGG::raceh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.raceh)
  return raceh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::RaceHist >*
AGG::mutable_raceh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.raceh)
  return &raceh_;
}

// repeated .comphealth.SourceHist sourceh = 6;
inline int AGG::sourceh_size() const {
  return sourceh_.size();
}
inline void AGG::clear_sourceh() {
  sourceh_.Clear();
}
inline const ::comphealth::SourceHist& AGG::sourceh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.sourceh)
  return sourceh_.Get(index);
}
inline ::comphealth::SourceHist* AGG::mutable_sourceh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.sourceh)
  return sourceh_.Mutable(index);
}
inline ::comphealth::SourceHist* AGG::add_sourceh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.sourceh)
  return sourceh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::SourceHist >&
AGG::sourceh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.sourceh)
  return sourceh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::SourceHist >*
AGG::mutable_sourceh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.sourceh)
  return &sourceh_;
}

// repeated .comphealth.DispositionHist disph = 7;
inline int AGG::disph_size() const {
  return disph_.size();
}
inline void AGG::clear_disph() {
  disph_.Clear();
}
inline const ::comphealth::DispositionHist& AGG::disph(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.disph)
  return disph_.Get(index);
}
inline ::comphealth::DispositionHist* AGG::mutable_disph(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.disph)
  return disph_.Mutable(index);
}
inline ::comphealth::DispositionHist* AGG::add_disph() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.disph)
  return disph_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DispositionHist >&
AGG::disph() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.disph)
  return disph_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::DispositionHist >*
AGG::mutable_disph() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.disph)
  return &disph_;
}

// repeated .comphealth.PayerHist payerh = 8;
inline int AGG::payerh_size() const {
  return payerh_.size();
}
inline void AGG::clear_payerh() {
  payerh_.Clear();
}
inline const ::comphealth::PayerHist& AGG::payerh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.payerh)
  return payerh_.Get(index);
}
inline ::comphealth::PayerHist* AGG::mutable_payerh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.payerh)
  return payerh_.Mutable(index);
}
inline ::comphealth::PayerHist* AGG::add_payerh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.payerh)
  return payerh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PayerHist >&
AGG::payerh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.payerh)
  return payerh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::PayerHist >*
AGG::mutable_payerh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.payerh)
  return &payerh_;
}

// repeated .comphealth.DeathHist deathh = 9;
inline int AGG::deathh_size() const {
  return deathh_.size();
}
inline void AGG::clear_deathh() {
  deathh_.Clear();
}
inline const ::comphealth::DeathHist& AGG::deathh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.deathh)
  return deathh_.Get(index);
}
inline ::comphealth::DeathHist* AGG::mutable_deathh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.deathh)
  return deathh_.Mutable(index);
}
inline ::comphealth::DeathHist* AGG::add_deathh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.deathh)
  return deathh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DeathHist >&
AGG::deathh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.deathh)
  return deathh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::DeathHist >*
AGG::mutable_deathh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.deathh)
  return &deathh_;
}

// repeated .comphealth.DXI dxh = 10;
inline int AGG::dxh_size() const {
  return dxh_.size();
}
inline void AGG::clear_dxh() {
  dxh_.Clear();
}
inline const ::comphealth::DXI& AGG::dxh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.dxh)
  return dxh_.Get(index);
}
inline ::comphealth::DXI* AGG::mutable_dxh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.dxh)
  return dxh_.Mutable(index);
}
inline ::comphealth::DXI* AGG::add_dxh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.dxh)
  return dxh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DXI >&
AGG::dxh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.dxh)
  return dxh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::DXI >*
AGG::mutable_dxh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.dxh)
  return &dxh_;
}

// repeated .comphealth.KVI primary_prh = 11;
inline int AGG::primary_prh_size() const {
  return primary_prh_.size();
}
inline void AGG::clear_primary_prh() {
  primary_prh_.Clear();
}
inline const ::comphealth::KVI& AGG::primary_prh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.primary_prh)
  return primary_prh_.Get(index);
}
inline ::comphealth::KVI* AGG::mutable_primary_prh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.primary_prh)
  return primary_prh_.Mutable(index);
}
inline ::comphealth::KVI* AGG::add_primary_prh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.primary_prh)
  return primary_prh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
AGG::primary_prh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.primary_prh)
  return primary_prh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
AGG::mutable_primary_prh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.primary_prh)
  return &primary_prh_;
}

// repeated .comphealth.KVI prh = 13;
inline int AGG::prh_size() const {
  return prh_.size();
}
inline void AGG::clear_prh() {
  prh_.Clear();
}
inline const ::comphealth::KVI& AGG::prh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.prh)
  return prh_.Get(index);
}
inline ::comphealth::KVI* AGG::mutable_prh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.prh)
  return prh_.Mutable(index);
}
inline ::comphealth::KVI* AGG::add_prh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.prh)
  return prh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
AGG::prh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.prh)
  return prh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
AGG::mutable_prh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.prh)
  return &prh_;
}

// repeated .comphealth.KVI exh = 14;
inline int AGG::exh_size() const {
  return exh_.size();
}
inline void AGG::clear_exh() {
  exh_.Clear();
}
inline const ::comphealth::KVI& AGG::exh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.exh)
  return exh_.Get(index);
}
inline ::comphealth::KVI* AGG::mutable_exh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.exh)
  return exh_.Mutable(index);
}
inline ::comphealth::KVI* AGG::add_exh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.exh)
  return exh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
AGG::exh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.exh)
  return exh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
AGG::mutable_exh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.exh)
  return &exh_;
}

// repeated .comphealth.KVI drgh = 15;
inline int AGG::drgh_size() const {
  return drgh_.size();
}
inline void AGG::clear_drgh() {
  drgh_.Clear();
}
inline const ::comphealth::KVI& AGG::drgh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.drgh)
  return drgh_.Get(index);
}
inline ::comphealth::KVI* AGG::mutable_drgh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.drgh)
  return drgh_.Mutable(index);
}
inline ::comphealth::KVI* AGG::add_drgh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.drgh)
  return drgh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >&
AGG::drgh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.drgh)
  return drgh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVI >*
AGG::mutable_drgh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.drgh)
  return &drgh_;
}

// optional .comphealth.IntHist losh = 16;
inline bool AGG::has_losh() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AGG::set_has_losh() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AGG::clear_has_losh() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AGG::clear_losh() {
  if (losh_ != NULL) losh_->::comphealth::IntHist::Clear();
  clear_has_losh();
}
inline const ::comphealth::IntHist& AGG::losh() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.losh)
  return losh_ != NULL ? *losh_ : *default_instance_->losh_;
}
inline ::comphealth::IntHist* AGG::mutable_losh() {
  set_has_losh();
  if (losh_ == NULL) losh_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.losh)
  return losh_;
}
inline ::comphealth::IntHist* AGG::release_losh() {
  clear_has_losh();
  ::comphealth::IntHist* temp = losh_;
  losh_ = NULL;
  return temp;
}
inline void AGG::set_allocated_losh(::comphealth::IntHist* losh) {
  delete losh_;
  losh_ = losh;
  if (losh) {
    set_has_losh();
  } else {
    clear_has_losh();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.AGG.losh)
}

// repeated .comphealth.DNRHist dnrh = 18;
inline int AGG::dnrh_size() const {
  return dnrh_.size();
}
inline void AGG::clear_dnrh() {
  dnrh_.Clear();
}
inline const ::comphealth::DNRHist& AGG::dnrh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.dnrh)
  return dnrh_.Get(index);
}
inline ::comphealth::DNRHist* AGG::mutable_dnrh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.dnrh)
  return dnrh_.Mutable(index);
}
inline ::comphealth::DNRHist* AGG::add_dnrh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.dnrh)
  return dnrh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::DNRHist >&
AGG::dnrh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.dnrh)
  return dnrh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::DNRHist >*
AGG::mutable_dnrh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.dnrh)
  return &dnrh_;
}

// repeated .comphealth.PZipHist pziph = 19;
inline int AGG::pziph_size() const {
  return pziph_.size();
}
inline void AGG::clear_pziph() {
  pziph_.Clear();
}
inline const ::comphealth::PZipHist& AGG::pziph(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.pziph)
  return pziph_.Get(index);
}
inline ::comphealth::PZipHist* AGG::mutable_pziph(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.pziph)
  return pziph_.Mutable(index);
}
inline ::comphealth::PZipHist* AGG::add_pziph() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.pziph)
  return pziph_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::PZipHist >&
AGG::pziph() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.pziph)
  return pziph_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::PZipHist >*
AGG::mutable_pziph() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.pziph)
  return &pziph_;
}

// repeated .comphealth.KVII agedh = 21;
inline int AGG::agedh_size() const {
  return agedh_.size();
}
inline void AGG::clear_agedh() {
  agedh_.Clear();
}
inline const ::comphealth::KVII& AGG::agedh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.agedh)
  return agedh_.Get(index);
}
inline ::comphealth::KVII* AGG::mutable_agedh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.agedh)
  return agedh_.Mutable(index);
}
inline ::comphealth::KVII* AGG::add_agedh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.agedh)
  return agedh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
AGG::agedh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.agedh)
  return agedh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
AGG::mutable_agedh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.agedh)
  return &agedh_;
}

// repeated .comphealth.KVII yearh = 22;
inline int AGG::yearh_size() const {
  return yearh_.size();
}
inline void AGG::clear_yearh() {
  yearh_.Clear();
}
inline const ::comphealth::KVII& AGG::yearh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.yearh)
  return yearh_.Get(index);
}
inline ::comphealth::KVII* AGG::mutable_yearh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.yearh)
  return yearh_.Mutable(index);
}
inline ::comphealth::KVII* AGG::add_yearh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.yearh)
  return yearh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
AGG::yearh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.yearh)
  return yearh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
AGG::mutable_yearh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.yearh)
  return &yearh_;
}

// repeated .comphealth.EtypeHist vtypeh = 23;
inline int AGG::vtypeh_size() const {
  return vtypeh_.size();
}
inline void AGG::clear_vtypeh() {
  vtypeh_.Clear();
}
inline const ::comphealth::EtypeHist& AGG::vtypeh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.vtypeh)
  return vtypeh_.Get(index);
}
inline ::comphealth::EtypeHist* AGG::mutable_vtypeh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.vtypeh)
  return vtypeh_.Mutable(index);
}
inline ::comphealth::EtypeHist* AGG::add_vtypeh() {
  // @@protoc_insertion_point(field_add:comphealth.AGG.vtypeh)
  return vtypeh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeHist >&
AGG::vtypeh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.vtypeh)
  return vtypeh_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::EtypeHist >*
AGG::mutable_vtypeh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.vtypeh)
  return &vtypeh_;
}

// repeated string facilityh = 24;
inline int AGG::facilityh_size() const {
  return facilityh_.size();
}
inline void AGG::clear_facilityh() {
  facilityh_.Clear();
}
inline const ::std::string& AGG::facilityh(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.facilityh)
  return facilityh_.Get(index);
}
inline ::std::string* AGG::mutable_facilityh(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.facilityh)
  return facilityh_.Mutable(index);
}
inline void AGG::set_facilityh(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:comphealth.AGG.facilityh)
  facilityh_.Mutable(index)->assign(value);
}
inline void AGG::set_facilityh(int index, const char* value) {
  facilityh_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.AGG.facilityh)
}
inline void AGG::set_facilityh(int index, const char* value, size_t size) {
  facilityh_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.AGG.facilityh)
}
inline ::std::string* AGG::add_facilityh() {
  return facilityh_.Add();
}
inline void AGG::add_facilityh(const ::std::string& value) {
  facilityh_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:comphealth.AGG.facilityh)
}
inline void AGG::add_facilityh(const char* value) {
  facilityh_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:comphealth.AGG.facilityh)
}
inline void AGG::add_facilityh(const char* value, size_t size) {
  facilityh_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:comphealth.AGG.facilityh)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AGG::facilityh() const {
  // @@protoc_insertion_point(field_list:comphealth.AGG.facilityh)
  return facilityh_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AGG::mutable_facilityh() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.AGG.facilityh)
  return &facilityh_;
}

// optional string dataset = 25;
inline bool AGG::has_dataset() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AGG::set_has_dataset() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AGG::clear_has_dataset() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AGG::clear_dataset() {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_->clear();
  }
  clear_has_dataset();
}
inline const ::std::string& AGG::dataset() const {
  // @@protoc_insertion_point(field_get:comphealth.AGG.dataset)
  return *dataset_;
}
inline void AGG::set_dataset(const ::std::string& value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.AGG.dataset)
}
inline void AGG::set_dataset(const char* value) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.AGG.dataset)
}
inline void AGG::set_dataset(const char* value, size_t size) {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  dataset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.AGG.dataset)
}
inline ::std::string* AGG::mutable_dataset() {
  set_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.AGG.dataset)
  return dataset_;
}
inline ::std::string* AGG::release_dataset() {
  clear_has_dataset();
  if (dataset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataset_;
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AGG::set_allocated_dataset(::std::string* dataset) {
  if (dataset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataset_;
  }
  if (dataset) {
    set_has_dataset();
    dataset_ = dataset;
  } else {
    clear_has_dataset();
    dataset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.AGG.dataset)
}

// -------------------------------------------------------------------

// Policy

// required int32 min_count = 1;
inline bool Policy::has_min_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Policy::set_has_min_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Policy::clear_has_min_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Policy::clear_min_count() {
  min_count_ = 0;
  clear_has_min_count();
}
inline ::google::protobuf::int32 Policy::min_count() const {
  // @@protoc_insertion_point(field_get:comphealth.Policy.min_count)
  return min_count_;
}
inline void Policy::set_min_count(::google::protobuf::int32 value) {
  set_has_min_count();
  min_count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Policy.min_count)
}

// required int32 min_hospital = 2;
inline bool Policy::has_min_hospital() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Policy::set_has_min_hospital() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Policy::clear_has_min_hospital() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Policy::clear_min_hospital() {
  min_hospital_ = 0;
  clear_has_min_hospital();
}
inline ::google::protobuf::int32 Policy::min_hospital() const {
  // @@protoc_insertion_point(field_get:comphealth.Policy.min_hospital)
  return min_hospital_;
}
inline void Policy::set_min_hospital(::google::protobuf::int32 value) {
  set_has_min_hospital();
  min_hospital_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Policy.min_hospital)
}

// required int32 base = 3;
inline bool Policy::has_base() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Policy::set_has_base() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Policy::clear_has_base() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Policy::clear_base() {
  base_ = 0;
  clear_has_base();
}
inline ::google::protobuf::int32 Policy::base() const {
  // @@protoc_insertion_point(field_get:comphealth.Policy.base)
  return base_;
}
inline void Policy::set_base(::google::protobuf::int32 value) {
  set_has_base();
  base_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Policy.base)
}

// required int32 min_subset = 4;
inline bool Policy::has_min_subset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Policy::set_has_min_subset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Policy::clear_has_min_subset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Policy::clear_min_subset() {
  min_subset_ = 0;
  clear_has_min_subset();
}
inline ::google::protobuf::int32 Policy::min_subset() const {
  // @@protoc_insertion_point(field_get:comphealth.Policy.min_subset)
  return min_subset_;
}
inline void Policy::set_min_subset(::google::protobuf::int32 value) {
  set_has_min_subset();
  min_subset_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Policy.min_subset)
}

// -------------------------------------------------------------------

// IntHist

// repeated .comphealth.KVII h = 1;
inline int IntHist::h_size() const {
  return h_.size();
}
inline void IntHist::clear_h() {
  h_.Clear();
}
inline const ::comphealth::KVII& IntHist::h(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.IntHist.h)
  return h_.Get(index);
}
inline ::comphealth::KVII* IntHist::mutable_h(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.IntHist.h)
  return h_.Mutable(index);
}
inline ::comphealth::KVII* IntHist::add_h() {
  // @@protoc_insertion_point(field_add:comphealth.IntHist.h)
  return h_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >&
IntHist::h() const {
  // @@protoc_insertion_point(field_list:comphealth.IntHist.h)
  return h_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::KVII >*
IntHist::mutable_h() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.IntHist.h)
  return &h_;
}

// optional int32 median = 2;
inline bool IntHist::has_median() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntHist::set_has_median() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntHist::clear_has_median() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntHist::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline ::google::protobuf::int32 IntHist::median() const {
  // @@protoc_insertion_point(field_get:comphealth.IntHist.median)
  return median_;
}
inline void IntHist::set_median(::google::protobuf::int32 value) {
  set_has_median();
  median_ = value;
  // @@protoc_insertion_point(field_set:comphealth.IntHist.median)
}

// optional int32 fq = 3;
inline bool IntHist::has_fq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntHist::set_has_fq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntHist::clear_has_fq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntHist::clear_fq() {
  fq_ = 0;
  clear_has_fq();
}
inline ::google::protobuf::int32 IntHist::fq() const {
  // @@protoc_insertion_point(field_get:comphealth.IntHist.fq)
  return fq_;
}
inline void IntHist::set_fq(::google::protobuf::int32 value) {
  set_has_fq();
  fq_ = value;
  // @@protoc_insertion_point(field_set:comphealth.IntHist.fq)
}

// optional int32 tq = 4;
inline bool IntHist::has_tq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntHist::set_has_tq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntHist::clear_has_tq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntHist::clear_tq() {
  tq_ = 0;
  clear_has_tq();
}
inline ::google::protobuf::int32 IntHist::tq() const {
  // @@protoc_insertion_point(field_get:comphealth.IntHist.tq)
  return tq_;
}
inline void IntHist::set_tq(::google::protobuf::int32 value) {
  set_has_tq();
  tq_ = value;
  // @@protoc_insertion_point(field_set:comphealth.IntHist.tq)
}

// optional float mean = 5;
inline bool IntHist::has_mean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IntHist::set_has_mean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IntHist::clear_has_mean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IntHist::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float IntHist::mean() const {
  // @@protoc_insertion_point(field_get:comphealth.IntHist.mean)
  return mean_;
}
inline void IntHist::set_mean(float value) {
  set_has_mean();
  mean_ = value;
  // @@protoc_insertion_point(field_set:comphealth.IntHist.mean)
}

// -------------------------------------------------------------------

// KVII

// required int32 k = 1;
inline bool KVII::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVII::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVII::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVII::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline ::google::protobuf::int32 KVII::k() const {
  // @@protoc_insertion_point(field_get:comphealth.KVII.k)
  return k_;
}
inline void KVII::set_k(::google::protobuf::int32 value) {
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.KVII.k)
}

// required int32 v = 2;
inline bool KVII::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVII::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVII::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVII::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 KVII::v() const {
  // @@protoc_insertion_point(field_get:comphealth.KVII.v)
  return v_;
}
inline void KVII::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.KVII.v)
}

// optional string s = 3;
inline bool KVII::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KVII::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KVII::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KVII::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& KVII::s() const {
  // @@protoc_insertion_point(field_get:comphealth.KVII.s)
  return *s_;
}
inline void KVII::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.KVII.s)
}
inline void KVII::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.KVII.s)
}
inline void KVII::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.KVII.s)
}
inline ::std::string* KVII::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.KVII.s)
  return s_;
}
inline ::std::string* KVII::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KVII::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.KVII.s)
}

// -------------------------------------------------------------------

// DXI

// required string k = 1;
inline bool DXI::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DXI::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DXI::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DXI::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& DXI::k() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.k)
  return *k_;
}
inline void DXI::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DXI.k)
}
inline void DXI::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DXI.k)
}
inline void DXI::set_k(const char* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DXI.k)
}
inline ::std::string* DXI::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DXI.k)
  return k_;
}
inline ::std::string* DXI::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DXI::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DXI.k)
}

// optional int32 primary = 2;
inline bool DXI::has_primary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DXI::set_has_primary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DXI::clear_has_primary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DXI::clear_primary() {
  primary_ = 0;
  clear_has_primary();
}
inline ::google::protobuf::int32 DXI::primary() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.primary)
  return primary_;
}
inline void DXI::set_primary(::google::protobuf::int32 value) {
  set_has_primary();
  primary_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DXI.primary)
}

// optional int32 poa = 3;
inline bool DXI::has_poa() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DXI::set_has_poa() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DXI::clear_has_poa() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DXI::clear_poa() {
  poa_ = 0;
  clear_has_poa();
}
inline ::google::protobuf::int32 DXI::poa() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.poa)
  return poa_;
}
inline void DXI::set_poa(::google::protobuf::int32 value) {
  set_has_poa();
  poa_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DXI.poa)
}

// optional int32 all = 4;
inline bool DXI::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DXI::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DXI::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DXI::clear_all() {
  all_ = 0;
  clear_has_all();
}
inline ::google::protobuf::int32 DXI::all() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.all)
  return all_;
}
inline void DXI::set_all(::google::protobuf::int32 value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DXI.all)
}

// optional string c = 5;
inline bool DXI::has_c() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DXI::set_has_c() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DXI::clear_has_c() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DXI::clear_c() {
  if (c_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    c_->clear();
  }
  clear_has_c();
}
inline const ::std::string& DXI::c() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.c)
  return *c_;
}
inline void DXI::set_c(const ::std::string& value) {
  set_has_c();
  if (c_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    c_ = new ::std::string;
  }
  c_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DXI.c)
}
inline void DXI::set_c(const char* value) {
  set_has_c();
  if (c_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    c_ = new ::std::string;
  }
  c_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DXI.c)
}
inline void DXI::set_c(const char* value, size_t size) {
  set_has_c();
  if (c_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    c_ = new ::std::string;
  }
  c_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DXI.c)
}
inline ::std::string* DXI::mutable_c() {
  set_has_c();
  if (c_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    c_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DXI.c)
  return c_;
}
inline ::std::string* DXI::release_c() {
  clear_has_c();
  if (c_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = c_;
    c_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DXI::set_allocated_c(::std::string* c) {
  if (c_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete c_;
  }
  if (c) {
    set_has_c();
    c_ = c;
  } else {
    clear_has_c();
    c_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DXI.c)
}

// optional string s = 6;
inline bool DXI::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DXI::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DXI::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DXI::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& DXI::s() const {
  // @@protoc_insertion_point(field_get:comphealth.DXI.s)
  return *s_;
}
inline void DXI::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DXI.s)
}
inline void DXI::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DXI.s)
}
inline void DXI::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DXI.s)
}
inline ::std::string* DXI::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DXI.s)
  return s_;
}
inline ::std::string* DXI::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DXI::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DXI.s)
}

// -------------------------------------------------------------------

// DispositionHist

// required .comphealth.DISPOSITION k = 1;
inline bool DispositionHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DispositionHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DispositionHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DispositionHist::clear_k() {
  k_ = 71;
  clear_has_k();
}
inline ::comphealth::DISPOSITION DispositionHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.DispositionHist.k)
  return static_cast< ::comphealth::DISPOSITION >(k_);
}
inline void DispositionHist::set_k(::comphealth::DISPOSITION value) {
  assert(::comphealth::DISPOSITION_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DispositionHist.k)
}

// required int32 v = 2;
inline bool DispositionHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DispositionHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DispositionHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DispositionHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 DispositionHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.DispositionHist.v)
  return v_;
}
inline void DispositionHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DispositionHist.v)
}

// optional string s = 3;
inline bool DispositionHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DispositionHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DispositionHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DispositionHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& DispositionHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.DispositionHist.s)
  return *s_;
}
inline void DispositionHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DispositionHist.s)
}
inline void DispositionHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DispositionHist.s)
}
inline void DispositionHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DispositionHist.s)
}
inline ::std::string* DispositionHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DispositionHist.s)
  return s_;
}
inline ::std::string* DispositionHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DispositionHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DispositionHist.s)
}

// -------------------------------------------------------------------

// EtypeHist

// required .comphealth.ETYPE k = 1;
inline bool EtypeHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EtypeHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EtypeHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EtypeHist::clear_k() {
  k_ = 0;
  clear_has_k();
}
inline ::comphealth::ETYPE EtypeHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeHist.k)
  return static_cast< ::comphealth::ETYPE >(k_);
}
inline void EtypeHist::set_k(::comphealth::ETYPE value) {
  assert(::comphealth::ETYPE_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeHist.k)
}

// required int32 v = 2;
inline bool EtypeHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EtypeHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EtypeHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EtypeHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 EtypeHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeHist.v)
  return v_;
}
inline void EtypeHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeHist.v)
}

// optional string s = 3;
inline bool EtypeHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EtypeHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EtypeHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EtypeHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& EtypeHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeHist.s)
  return *s_;
}
inline void EtypeHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.EtypeHist.s)
}
inline void EtypeHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.EtypeHist.s)
}
inline void EtypeHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.EtypeHist.s)
}
inline ::std::string* EtypeHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.EtypeHist.s)
  return s_;
}
inline ::std::string* EtypeHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EtypeHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.EtypeHist.s)
}

// -------------------------------------------------------------------

// EtypeCountHist

// required bool linked = 5;
inline bool EtypeCountHist::has_linked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EtypeCountHist::set_has_linked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EtypeCountHist::clear_has_linked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EtypeCountHist::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool EtypeCountHist::linked() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeCountHist.linked)
  return linked_;
}
inline void EtypeCountHist::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeCountHist.linked)
}

// required int32 ip = 1;
inline bool EtypeCountHist::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EtypeCountHist::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EtypeCountHist::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EtypeCountHist::clear_ip() {
  ip_ = 0;
  clear_has_ip();
}
inline ::google::protobuf::int32 EtypeCountHist::ip() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeCountHist.ip)
  return ip_;
}
inline void EtypeCountHist::set_ip(::google::protobuf::int32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeCountHist.ip)
}

// required int32 ed = 2;
inline bool EtypeCountHist::has_ed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EtypeCountHist::set_has_ed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EtypeCountHist::clear_has_ed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EtypeCountHist::clear_ed() {
  ed_ = 0;
  clear_has_ed();
}
inline ::google::protobuf::int32 EtypeCountHist::ed() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeCountHist.ed)
  return ed_;
}
inline void EtypeCountHist::set_ed(::google::protobuf::int32 value) {
  set_has_ed();
  ed_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeCountHist.ed)
}

// required int32 asg = 3;
inline bool EtypeCountHist::has_asg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EtypeCountHist::set_has_asg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EtypeCountHist::clear_has_asg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EtypeCountHist::clear_asg() {
  asg_ = 0;
  clear_has_asg();
}
inline ::google::protobuf::int32 EtypeCountHist::asg() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeCountHist.asg)
  return asg_;
}
inline void EtypeCountHist::set_asg(::google::protobuf::int32 value) {
  set_has_asg();
  asg_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeCountHist.asg)
}

// required int32 v = 4;
inline bool EtypeCountHist::has_v() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EtypeCountHist::set_has_v() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EtypeCountHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EtypeCountHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 EtypeCountHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.EtypeCountHist.v)
  return v_;
}
inline void EtypeCountHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.EtypeCountHist.v)
}

// -------------------------------------------------------------------

// SourceHist

// required .comphealth.SOURCE k = 1;
inline bool SourceHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SourceHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SourceHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SourceHist::clear_k() {
  k_ = 61;
  clear_has_k();
}
inline ::comphealth::SOURCE SourceHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.SourceHist.k)
  return static_cast< ::comphealth::SOURCE >(k_);
}
inline void SourceHist::set_k(::comphealth::SOURCE value) {
  assert(::comphealth::SOURCE_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.SourceHist.k)
}

// required int32 v = 2;
inline bool SourceHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SourceHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SourceHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SourceHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 SourceHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.SourceHist.v)
  return v_;
}
inline void SourceHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.SourceHist.v)
}

// optional string s = 3;
inline bool SourceHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SourceHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SourceHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SourceHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& SourceHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.SourceHist.s)
  return *s_;
}
inline void SourceHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.SourceHist.s)
}
inline void SourceHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.SourceHist.s)
}
inline void SourceHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.SourceHist.s)
}
inline ::std::string* SourceHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.SourceHist.s)
  return s_;
}
inline ::std::string* SourceHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SourceHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.SourceHist.s)
}

// -------------------------------------------------------------------

// PayerHist

// required .comphealth.PAYER k = 1;
inline bool PayerHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayerHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayerHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayerHist::clear_k() {
  k_ = 41;
  clear_has_k();
}
inline ::comphealth::PAYER PayerHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.PayerHist.k)
  return static_cast< ::comphealth::PAYER >(k_);
}
inline void PayerHist::set_k(::comphealth::PAYER value) {
  assert(::comphealth::PAYER_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PayerHist.k)
}

// required int32 v = 2;
inline bool PayerHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayerHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayerHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayerHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 PayerHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.PayerHist.v)
  return v_;
}
inline void PayerHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PayerHist.v)
}

// optional string s = 3;
inline bool PayerHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayerHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayerHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayerHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& PayerHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.PayerHist.s)
  return *s_;
}
inline void PayerHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PayerHist.s)
}
inline void PayerHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PayerHist.s)
}
inline void PayerHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PayerHist.s)
}
inline ::std::string* PayerHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PayerHist.s)
  return s_;
}
inline ::std::string* PayerHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayerHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PayerHist.s)
}

// -------------------------------------------------------------------

// RaceHist

// required .comphealth.RACE k = 1;
inline bool RaceHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaceHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaceHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaceHist::clear_k() {
  k_ = 51;
  clear_has_k();
}
inline ::comphealth::RACE RaceHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.RaceHist.k)
  return static_cast< ::comphealth::RACE >(k_);
}
inline void RaceHist::set_k(::comphealth::RACE value) {
  assert(::comphealth::RACE_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.RaceHist.k)
}

// required int32 v = 2;
inline bool RaceHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaceHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaceHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaceHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 RaceHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.RaceHist.v)
  return v_;
}
inline void RaceHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.RaceHist.v)
}

// optional string s = 3;
inline bool RaceHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaceHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaceHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaceHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& RaceHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.RaceHist.s)
  return *s_;
}
inline void RaceHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.RaceHist.s)
}
inline void RaceHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.RaceHist.s)
}
inline void RaceHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.RaceHist.s)
}
inline ::std::string* RaceHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.RaceHist.s)
  return s_;
}
inline ::std::string* RaceHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RaceHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.RaceHist.s)
}

// -------------------------------------------------------------------

// DeathHist

// required .comphealth.DEATH k = 1;
inline bool DeathHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeathHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeathHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeathHist::clear_k() {
  k_ = 30;
  clear_has_k();
}
inline ::comphealth::DEATH DeathHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.DeathHist.k)
  return static_cast< ::comphealth::DEATH >(k_);
}
inline void DeathHist::set_k(::comphealth::DEATH value) {
  assert(::comphealth::DEATH_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DeathHist.k)
}

// required int32 v = 2;
inline bool DeathHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeathHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeathHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeathHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 DeathHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.DeathHist.v)
  return v_;
}
inline void DeathHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DeathHist.v)
}

// optional string s = 3;
inline bool DeathHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeathHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeathHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeathHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& DeathHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.DeathHist.s)
  return *s_;
}
inline void DeathHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DeathHist.s)
}
inline void DeathHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DeathHist.s)
}
inline void DeathHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DeathHist.s)
}
inline ::std::string* DeathHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DeathHist.s)
  return s_;
}
inline ::std::string* DeathHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeathHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DeathHist.s)
}

// -------------------------------------------------------------------

// SexHist

// required .comphealth.SEX k = 1;
inline bool SexHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SexHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SexHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SexHist::clear_k() {
  k_ = 10;
  clear_has_k();
}
inline ::comphealth::SEX SexHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.SexHist.k)
  return static_cast< ::comphealth::SEX >(k_);
}
inline void SexHist::set_k(::comphealth::SEX value) {
  assert(::comphealth::SEX_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.SexHist.k)
}

// required int32 v = 2;
inline bool SexHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SexHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SexHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SexHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 SexHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.SexHist.v)
  return v_;
}
inline void SexHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.SexHist.v)
}

// optional string s = 3;
inline bool SexHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SexHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SexHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SexHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& SexHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.SexHist.s)
  return *s_;
}
inline void SexHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.SexHist.s)
}
inline void SexHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.SexHist.s)
}
inline void SexHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.SexHist.s)
}
inline ::std::string* SexHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.SexHist.s)
  return s_;
}
inline ::std::string* SexHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SexHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.SexHist.s)
}

// -------------------------------------------------------------------

// DNRHist

// required .comphealth.DNR k = 1;
inline bool DNRHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DNRHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DNRHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DNRHist::clear_k() {
  k_ = 80;
  clear_has_k();
}
inline ::comphealth::DNR DNRHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.DNRHist.k)
  return static_cast< ::comphealth::DNR >(k_);
}
inline void DNRHist::set_k(::comphealth::DNR value) {
  assert(::comphealth::DNR_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DNRHist.k)
}

// required int32 v = 2;
inline bool DNRHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DNRHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DNRHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DNRHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 DNRHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.DNRHist.v)
  return v_;
}
inline void DNRHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.DNRHist.v)
}

// optional string s = 3;
inline bool DNRHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DNRHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DNRHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DNRHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& DNRHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.DNRHist.s)
  return *s_;
}
inline void DNRHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.DNRHist.s)
}
inline void DNRHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.DNRHist.s)
}
inline void DNRHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.DNRHist.s)
}
inline ::std::string* DNRHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.DNRHist.s)
  return s_;
}
inline ::std::string* DNRHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DNRHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.DNRHist.s)
}

// -------------------------------------------------------------------

// PZipHist

// required .comphealth.PZIP k = 1;
inline bool PZipHist::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PZipHist::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PZipHist::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PZipHist::clear_k() {
  k_ = 101;
  clear_has_k();
}
inline ::comphealth::PZIP PZipHist::k() const {
  // @@protoc_insertion_point(field_get:comphealth.PZipHist.k)
  return static_cast< ::comphealth::PZIP >(k_);
}
inline void PZipHist::set_k(::comphealth::PZIP value) {
  assert(::comphealth::PZIP_IsValid(value));
  set_has_k();
  k_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PZipHist.k)
}

// required int32 v = 2;
inline bool PZipHist::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PZipHist::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PZipHist::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PZipHist::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 PZipHist::v() const {
  // @@protoc_insertion_point(field_get:comphealth.PZipHist.v)
  return v_;
}
inline void PZipHist::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PZipHist.v)
}

// optional string s = 3;
inline bool PZipHist::has_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PZipHist::set_has_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PZipHist::clear_has_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PZipHist::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& PZipHist::s() const {
  // @@protoc_insertion_point(field_get:comphealth.PZipHist.s)
  return *s_;
}
inline void PZipHist::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PZipHist.s)
}
inline void PZipHist::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PZipHist.s)
}
inline void PZipHist::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PZipHist.s)
}
inline ::std::string* PZipHist::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PZipHist.s)
  return s_;
}
inline ::std::string* PZipHist::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PZipHist::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PZipHist.s)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pstat_2eproto__INCLUDED
